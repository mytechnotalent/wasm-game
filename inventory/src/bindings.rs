// Generated by `wit-bindgen` 0.41.0. DO NOT EDIT!
// Options used:
//   * runtime_path: "wit_bindgen_rt"
#[rustfmt::skip]
#[allow(dead_code, clippy::all)]
pub mod exports {
    pub mod docs {
        pub mod inventory {
            /// Item type definitions and data structures.
            #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
            pub mod types {
                #[used]
                #[doc(hidden)]
                static __FORCE_SECTION_REF: fn() = super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                /// Categories of items in the game.
                #[repr(u8)]
                #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
                pub enum ItemCategory {
                    /// Offensive weapons (swords, bows).
                    Weapon,
                    /// Defensive equipment (shields, armor).
                    Armor,
                    /// Consumable items (potions, food).
                    Consumable,
                    /// Quest and dungeon keys.
                    KeyItem,
                    /// Collectible treasures.
                    Treasure,
                }
                impl ::core::fmt::Debug for ItemCategory {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        match self {
                            ItemCategory::Weapon => {
                                f.debug_tuple("ItemCategory::Weapon").finish()
                            }
                            ItemCategory::Armor => {
                                f.debug_tuple("ItemCategory::Armor").finish()
                            }
                            ItemCategory::Consumable => {
                                f.debug_tuple("ItemCategory::Consumable").finish()
                            }
                            ItemCategory::KeyItem => {
                                f.debug_tuple("ItemCategory::KeyItem").finish()
                            }
                            ItemCategory::Treasure => {
                                f.debug_tuple("ItemCategory::Treasure").finish()
                            }
                        }
                    }
                }
                impl ItemCategory {
                    #[doc(hidden)]
                    pub unsafe fn _lift(val: u8) -> ItemCategory {
                        if !cfg!(debug_assertions) {
                            return ::core::mem::transmute(val);
                        }
                        match val {
                            0 => ItemCategory::Weapon,
                            1 => ItemCategory::Armor,
                            2 => ItemCategory::Consumable,
                            3 => ItemCategory::KeyItem,
                            4 => ItemCategory::Treasure,
                            _ => panic!("invalid enum discriminant"),
                        }
                    }
                }
                /// Specific weapon types.
                #[repr(u8)]
                #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
                pub enum WeaponType {
                    /// Basic wooden sword.
                    WoodenSword,
                    /// Standard steel sword.
                    SteelSword,
                    /// Powerful master sword.
                    MasterSword,
                    /// Ranged bow weapon.
                    Bow,
                    /// Magical fire rod.
                    FireRod,
                }
                impl ::core::fmt::Debug for WeaponType {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        match self {
                            WeaponType::WoodenSword => {
                                f.debug_tuple("WeaponType::WoodenSword").finish()
                            }
                            WeaponType::SteelSword => {
                                f.debug_tuple("WeaponType::SteelSword").finish()
                            }
                            WeaponType::MasterSword => {
                                f.debug_tuple("WeaponType::MasterSword").finish()
                            }
                            WeaponType::Bow => f.debug_tuple("WeaponType::Bow").finish(),
                            WeaponType::FireRod => {
                                f.debug_tuple("WeaponType::FireRod").finish()
                            }
                        }
                    }
                }
                impl WeaponType {
                    #[doc(hidden)]
                    pub unsafe fn _lift(val: u8) -> WeaponType {
                        if !cfg!(debug_assertions) {
                            return ::core::mem::transmute(val);
                        }
                        match val {
                            0 => WeaponType::WoodenSword,
                            1 => WeaponType::SteelSword,
                            2 => WeaponType::MasterSword,
                            3 => WeaponType::Bow,
                            4 => WeaponType::FireRod,
                            _ => panic!("invalid enum discriminant"),
                        }
                    }
                }
                /// Specific armor types.
                #[repr(u8)]
                #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
                pub enum ArmorType {
                    /// Basic cloth tunic.
                    ClothTunic,
                    /// Leather armor.
                    LeatherArmor,
                    /// Chain mail armor.
                    ChainMail,
                    /// Protective shield.
                    Shield,
                    /// Magic-enhancing robe.
                    MagicRobe,
                }
                impl ::core::fmt::Debug for ArmorType {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        match self {
                            ArmorType::ClothTunic => {
                                f.debug_tuple("ArmorType::ClothTunic").finish()
                            }
                            ArmorType::LeatherArmor => {
                                f.debug_tuple("ArmorType::LeatherArmor").finish()
                            }
                            ArmorType::ChainMail => {
                                f.debug_tuple("ArmorType::ChainMail").finish()
                            }
                            ArmorType::Shield => {
                                f.debug_tuple("ArmorType::Shield").finish()
                            }
                            ArmorType::MagicRobe => {
                                f.debug_tuple("ArmorType::MagicRobe").finish()
                            }
                        }
                    }
                }
                impl ArmorType {
                    #[doc(hidden)]
                    pub unsafe fn _lift(val: u8) -> ArmorType {
                        if !cfg!(debug_assertions) {
                            return ::core::mem::transmute(val);
                        }
                        match val {
                            0 => ArmorType::ClothTunic,
                            1 => ArmorType::LeatherArmor,
                            2 => ArmorType::ChainMail,
                            3 => ArmorType::Shield,
                            4 => ArmorType::MagicRobe,
                            _ => panic!("invalid enum discriminant"),
                        }
                    }
                }
                /// Consumable item types.
                #[repr(u8)]
                #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
                pub enum ConsumableType {
                    /// Restores health.
                    HealthPotion,
                    /// Fully restores health.
                    FullHealthPotion,
                    /// Temporarily boosts attack.
                    AttackBoost,
                    /// Temporarily boosts defense.
                    DefenseBoost,
                    /// Antidote for poison.
                    Antidote,
                }
                impl ::core::fmt::Debug for ConsumableType {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        match self {
                            ConsumableType::HealthPotion => {
                                f.debug_tuple("ConsumableType::HealthPotion").finish()
                            }
                            ConsumableType::FullHealthPotion => {
                                f.debug_tuple("ConsumableType::FullHealthPotion").finish()
                            }
                            ConsumableType::AttackBoost => {
                                f.debug_tuple("ConsumableType::AttackBoost").finish()
                            }
                            ConsumableType::DefenseBoost => {
                                f.debug_tuple("ConsumableType::DefenseBoost").finish()
                            }
                            ConsumableType::Antidote => {
                                f.debug_tuple("ConsumableType::Antidote").finish()
                            }
                        }
                    }
                }
                impl ConsumableType {
                    #[doc(hidden)]
                    pub unsafe fn _lift(val: u8) -> ConsumableType {
                        if !cfg!(debug_assertions) {
                            return ::core::mem::transmute(val);
                        }
                        match val {
                            0 => ConsumableType::HealthPotion,
                            1 => ConsumableType::FullHealthPotion,
                            2 => ConsumableType::AttackBoost,
                            3 => ConsumableType::DefenseBoost,
                            4 => ConsumableType::Antidote,
                            _ => panic!("invalid enum discriminant"),
                        }
                    }
                }
                /// A single inventory item.
                #[derive(Clone)]
                pub struct Item {
                    /// Unique item identifier.
                    pub id: u32,
                    /// Item's display name.
                    pub name: _rt::String,
                    /// Item category.
                    pub category: ItemCategory,
                    /// Attack bonus (for weapons).
                    pub attack_bonus: u32,
                    /// Defense bonus (for armor).
                    pub defense_bonus: u32,
                    /// Healing amount (for consumables).
                    pub heal_amount: u32,
                    /// Current quantity in inventory.
                    pub quantity: u32,
                    /// Whether this item is currently equipped.
                    pub is_equipped: bool,
                }
                impl ::core::fmt::Debug for Item {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("Item")
                            .field("id", &self.id)
                            .field("name", &self.name)
                            .field("category", &self.category)
                            .field("attack-bonus", &self.attack_bonus)
                            .field("defense-bonus", &self.defense_bonus)
                            .field("heal-amount", &self.heal_amount)
                            .field("quantity", &self.quantity)
                            .field("is-equipped", &self.is_equipped)
                            .finish()
                    }
                }
                /// Player's complete inventory state.
                #[repr(C)]
                #[derive(Clone, Copy)]
                pub struct InventoryState {
                    /// Currently equipped weapon ID (0 = none).
                    pub equipped_weapon: u32,
                    /// Currently equipped armor ID (0 = none).
                    pub equipped_armor: u32,
                    /// Total number of items in inventory.
                    pub item_count: u32,
                    /// Maximum inventory capacity.
                    pub max_capacity: u32,
                    /// Gold/rupees currency.
                    pub gold: u32,
                }
                impl ::core::fmt::Debug for InventoryState {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("InventoryState")
                            .field("equipped-weapon", &self.equipped_weapon)
                            .field("equipped-armor", &self.equipped_armor)
                            .field("item-count", &self.item_count)
                            .field("max-capacity", &self.max_capacity)
                            .field("gold", &self.gold)
                            .finish()
                    }
                }
                /// Result of using an item.
                #[derive(Clone)]
                pub struct UseResult {
                    /// Whether the item was successfully used.
                    pub success: bool,
                    /// Health restored (if applicable).
                    pub health_restored: u32,
                    /// Attack boost applied (if applicable).
                    pub attack_boost: u32,
                    /// Defense boost applied (if applicable).
                    pub defense_boost: u32,
                    /// Message describing the result.
                    pub message: _rt::String,
                }
                impl ::core::fmt::Debug for UseResult {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("UseResult")
                            .field("success", &self.success)
                            .field("health-restored", &self.health_restored)
                            .field("attack-boost", &self.attack_boost)
                            .field("defense-boost", &self.defense_boost)
                            .field("message", &self.message)
                            .finish()
                    }
                }
                #[doc(hidden)]
                macro_rules! __export_docs_inventory_types_0_1_0_cabi {
                    ($ty:ident with_types_in $($path_to_types:tt)*) => {
                        const _ : () = {};
                    };
                }
                #[doc(hidden)]
                pub(crate) use __export_docs_inventory_types_0_1_0_cabi;
            }
            /// Item creation and lookup interface.
            #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
            pub mod items {
                #[used]
                #[doc(hidden)]
                static __FORCE_SECTION_REF: fn() = super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Item = super::super::super::super::exports::docs::inventory::types::Item;
                pub type WeaponType = super::super::super::super::exports::docs::inventory::types::WeaponType;
                pub type ArmorType = super::super::super::super::exports::docs::inventory::types::ArmorType;
                pub type ConsumableType = super::super::super::super::exports::docs::inventory::types::ConsumableType;
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_create_weapon_cabi<T: Guest>(
                    arg0: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::create_weapon(
                        super::super::super::super::exports::docs::inventory::types::WeaponType::_lift(
                            arg0 as u8,
                        ),
                    );
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let super::super::super::super::exports::docs::inventory::types::Item {
                        id: id2,
                        name: name2,
                        category: category2,
                        attack_bonus: attack_bonus2,
                        defense_bonus: defense_bonus2,
                        heal_amount: heal_amount2,
                        quantity: quantity2,
                        is_equipped: is_equipped2,
                    } = result0;
                    *ptr1.add(0).cast::<i32>() = _rt::as_i32(id2);
                    let vec3 = (name2.into_bytes()).into_boxed_slice();
                    let ptr3 = vec3.as_ptr().cast::<u8>();
                    let len3 = vec3.len();
                    ::core::mem::forget(vec3);
                    *ptr1.add(2 * ::core::mem::size_of::<*const u8>()).cast::<usize>() = len3;
                    *ptr1.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr3
                        .cast_mut();
                    *ptr1.add(3 * ::core::mem::size_of::<*const u8>()).cast::<u8>() = (category2
                        .clone() as i32) as u8;
                    *ptr1
                        .add(4 + 3 * ::core::mem::size_of::<*const u8>())
                        .cast::<i32>() = _rt::as_i32(attack_bonus2);
                    *ptr1
                        .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                        .cast::<i32>() = _rt::as_i32(defense_bonus2);
                    *ptr1
                        .add(12 + 3 * ::core::mem::size_of::<*const u8>())
                        .cast::<i32>() = _rt::as_i32(heal_amount2);
                    *ptr1
                        .add(16 + 3 * ::core::mem::size_of::<*const u8>())
                        .cast::<i32>() = _rt::as_i32(quantity2);
                    *ptr1
                        .add(20 + 3 * ::core::mem::size_of::<*const u8>())
                        .cast::<u8>() = (match is_equipped2 {
                        true => 1,
                        false => 0,
                    }) as u8;
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_create_weapon<T: Guest>(arg0: *mut u8) {
                    let l0 = *arg0
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l1 = *arg0
                        .add(2 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    _rt::cabi_dealloc(l0, l1, 1);
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_create_armor_cabi<T: Guest>(arg0: i32) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::create_armor(
                        super::super::super::super::exports::docs::inventory::types::ArmorType::_lift(
                            arg0 as u8,
                        ),
                    );
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let super::super::super::super::exports::docs::inventory::types::Item {
                        id: id2,
                        name: name2,
                        category: category2,
                        attack_bonus: attack_bonus2,
                        defense_bonus: defense_bonus2,
                        heal_amount: heal_amount2,
                        quantity: quantity2,
                        is_equipped: is_equipped2,
                    } = result0;
                    *ptr1.add(0).cast::<i32>() = _rt::as_i32(id2);
                    let vec3 = (name2.into_bytes()).into_boxed_slice();
                    let ptr3 = vec3.as_ptr().cast::<u8>();
                    let len3 = vec3.len();
                    ::core::mem::forget(vec3);
                    *ptr1.add(2 * ::core::mem::size_of::<*const u8>()).cast::<usize>() = len3;
                    *ptr1.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr3
                        .cast_mut();
                    *ptr1.add(3 * ::core::mem::size_of::<*const u8>()).cast::<u8>() = (category2
                        .clone() as i32) as u8;
                    *ptr1
                        .add(4 + 3 * ::core::mem::size_of::<*const u8>())
                        .cast::<i32>() = _rt::as_i32(attack_bonus2);
                    *ptr1
                        .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                        .cast::<i32>() = _rt::as_i32(defense_bonus2);
                    *ptr1
                        .add(12 + 3 * ::core::mem::size_of::<*const u8>())
                        .cast::<i32>() = _rt::as_i32(heal_amount2);
                    *ptr1
                        .add(16 + 3 * ::core::mem::size_of::<*const u8>())
                        .cast::<i32>() = _rt::as_i32(quantity2);
                    *ptr1
                        .add(20 + 3 * ::core::mem::size_of::<*const u8>())
                        .cast::<u8>() = (match is_equipped2 {
                        true => 1,
                        false => 0,
                    }) as u8;
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_create_armor<T: Guest>(arg0: *mut u8) {
                    let l0 = *arg0
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l1 = *arg0
                        .add(2 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    _rt::cabi_dealloc(l0, l1, 1);
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_create_consumable_cabi<T: Guest>(
                    arg0: i32,
                    arg1: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::create_consumable(
                        super::super::super::super::exports::docs::inventory::types::ConsumableType::_lift(
                            arg0 as u8,
                        ),
                        arg1 as u32,
                    );
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let super::super::super::super::exports::docs::inventory::types::Item {
                        id: id2,
                        name: name2,
                        category: category2,
                        attack_bonus: attack_bonus2,
                        defense_bonus: defense_bonus2,
                        heal_amount: heal_amount2,
                        quantity: quantity2,
                        is_equipped: is_equipped2,
                    } = result0;
                    *ptr1.add(0).cast::<i32>() = _rt::as_i32(id2);
                    let vec3 = (name2.into_bytes()).into_boxed_slice();
                    let ptr3 = vec3.as_ptr().cast::<u8>();
                    let len3 = vec3.len();
                    ::core::mem::forget(vec3);
                    *ptr1.add(2 * ::core::mem::size_of::<*const u8>()).cast::<usize>() = len3;
                    *ptr1.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr3
                        .cast_mut();
                    *ptr1.add(3 * ::core::mem::size_of::<*const u8>()).cast::<u8>() = (category2
                        .clone() as i32) as u8;
                    *ptr1
                        .add(4 + 3 * ::core::mem::size_of::<*const u8>())
                        .cast::<i32>() = _rt::as_i32(attack_bonus2);
                    *ptr1
                        .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                        .cast::<i32>() = _rt::as_i32(defense_bonus2);
                    *ptr1
                        .add(12 + 3 * ::core::mem::size_of::<*const u8>())
                        .cast::<i32>() = _rt::as_i32(heal_amount2);
                    *ptr1
                        .add(16 + 3 * ::core::mem::size_of::<*const u8>())
                        .cast::<i32>() = _rt::as_i32(quantity2);
                    *ptr1
                        .add(20 + 3 * ::core::mem::size_of::<*const u8>())
                        .cast::<u8>() = (match is_equipped2 {
                        true => 1,
                        false => 0,
                    }) as u8;
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_create_consumable<T: Guest>(arg0: *mut u8) {
                    let l0 = *arg0
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l1 = *arg0
                        .add(2 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    _rt::cabi_dealloc(l0, l1, 1);
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_get_item_stats_cabi<T: Guest>(
                    arg0: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::get_item_stats(arg0 as u32);
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let super::super::super::super::exports::docs::inventory::types::Item {
                        id: id2,
                        name: name2,
                        category: category2,
                        attack_bonus: attack_bonus2,
                        defense_bonus: defense_bonus2,
                        heal_amount: heal_amount2,
                        quantity: quantity2,
                        is_equipped: is_equipped2,
                    } = result0;
                    *ptr1.add(0).cast::<i32>() = _rt::as_i32(id2);
                    let vec3 = (name2.into_bytes()).into_boxed_slice();
                    let ptr3 = vec3.as_ptr().cast::<u8>();
                    let len3 = vec3.len();
                    ::core::mem::forget(vec3);
                    *ptr1.add(2 * ::core::mem::size_of::<*const u8>()).cast::<usize>() = len3;
                    *ptr1.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr3
                        .cast_mut();
                    *ptr1.add(3 * ::core::mem::size_of::<*const u8>()).cast::<u8>() = (category2
                        .clone() as i32) as u8;
                    *ptr1
                        .add(4 + 3 * ::core::mem::size_of::<*const u8>())
                        .cast::<i32>() = _rt::as_i32(attack_bonus2);
                    *ptr1
                        .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                        .cast::<i32>() = _rt::as_i32(defense_bonus2);
                    *ptr1
                        .add(12 + 3 * ::core::mem::size_of::<*const u8>())
                        .cast::<i32>() = _rt::as_i32(heal_amount2);
                    *ptr1
                        .add(16 + 3 * ::core::mem::size_of::<*const u8>())
                        .cast::<i32>() = _rt::as_i32(quantity2);
                    *ptr1
                        .add(20 + 3 * ::core::mem::size_of::<*const u8>())
                        .cast::<u8>() = (match is_equipped2 {
                        true => 1,
                        false => 0,
                    }) as u8;
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_get_item_stats<T: Guest>(arg0: *mut u8) {
                    let l0 = *arg0
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l1 = *arg0
                        .add(2 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    _rt::cabi_dealloc(l0, l1, 1);
                }
                pub trait Guest {
                    /// Create a weapon item.
                    fn create_weapon(weapon: WeaponType) -> Item;
                    /// Create an armor item.
                    fn create_armor(armor: ArmorType) -> Item;
                    /// Create a consumable item.
                    fn create_consumable(
                        consumable: ConsumableType,
                        quantity: u32,
                    ) -> Item;
                    /// Get item stats by ID.
                    fn get_item_stats(item_id: u32) -> Item;
                }
                #[doc(hidden)]
                macro_rules! __export_docs_inventory_items_0_1_0_cabi {
                    ($ty:ident with_types_in $($path_to_types:tt)*) => {
                        const _ : () = { #[unsafe (export_name =
                        "docs:inventory/items@0.1.0#create-weapon")] unsafe extern "C" fn
                        export_create_weapon(arg0 : i32,) -> * mut u8 { unsafe {
                        $($path_to_types)*:: _export_create_weapon_cabi::<$ty > (arg0) }
                        } #[unsafe (export_name =
                        "cabi_post_docs:inventory/items@0.1.0#create-weapon")] unsafe
                        extern "C" fn _post_return_create_weapon(arg0 : * mut u8,) {
                        unsafe { $($path_to_types)*:: __post_return_create_weapon::<$ty >
                        (arg0) } } #[unsafe (export_name =
                        "docs:inventory/items@0.1.0#create-armor")] unsafe extern "C" fn
                        export_create_armor(arg0 : i32,) -> * mut u8 { unsafe {
                        $($path_to_types)*:: _export_create_armor_cabi::<$ty > (arg0) } }
                        #[unsafe (export_name =
                        "cabi_post_docs:inventory/items@0.1.0#create-armor")] unsafe
                        extern "C" fn _post_return_create_armor(arg0 : * mut u8,) {
                        unsafe { $($path_to_types)*:: __post_return_create_armor::<$ty >
                        (arg0) } } #[unsafe (export_name =
                        "docs:inventory/items@0.1.0#create-consumable")] unsafe extern
                        "C" fn export_create_consumable(arg0 : i32, arg1 : i32,) -> * mut
                        u8 { unsafe { $($path_to_types)*::
                        _export_create_consumable_cabi::<$ty > (arg0, arg1) } } #[unsafe
                        (export_name =
                        "cabi_post_docs:inventory/items@0.1.0#create-consumable")] unsafe
                        extern "C" fn _post_return_create_consumable(arg0 : * mut u8,) {
                        unsafe { $($path_to_types)*::
                        __post_return_create_consumable::<$ty > (arg0) } } #[unsafe
                        (export_name = "docs:inventory/items@0.1.0#get-item-stats")]
                        unsafe extern "C" fn export_get_item_stats(arg0 : i32,) -> * mut
                        u8 { unsafe { $($path_to_types)*::
                        _export_get_item_stats_cabi::<$ty > (arg0) } } #[unsafe
                        (export_name =
                        "cabi_post_docs:inventory/items@0.1.0#get-item-stats")] unsafe
                        extern "C" fn _post_return_get_item_stats(arg0 : * mut u8,) {
                        unsafe { $($path_to_types)*:: __post_return_get_item_stats::<$ty
                        > (arg0) } } };
                    };
                }
                #[doc(hidden)]
                pub(crate) use __export_docs_inventory_items_0_1_0_cabi;
                #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                struct _RetArea(
                    [::core::mem::MaybeUninit<
                        u8,
                    >; 24 + 3 * ::core::mem::size_of::<*const u8>()],
                );
                static mut _RET_AREA: _RetArea = _RetArea(
                    [::core::mem::MaybeUninit::uninit(); 24
                        + 3 * ::core::mem::size_of::<*const u8>()],
                );
            }
            /// Inventory management interface.
            #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
            pub mod management {
                #[used]
                #[doc(hidden)]
                static __FORCE_SECTION_REF: fn() = super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type InventoryState = super::super::super::super::exports::docs::inventory::types::InventoryState;
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_create_inventory_cabi<T: Guest>() -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::create_inventory();
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let super::super::super::super::exports::docs::inventory::types::InventoryState {
                        equipped_weapon: equipped_weapon2,
                        equipped_armor: equipped_armor2,
                        item_count: item_count2,
                        max_capacity: max_capacity2,
                        gold: gold2,
                    } = result0;
                    *ptr1.add(0).cast::<i32>() = _rt::as_i32(equipped_weapon2);
                    *ptr1.add(4).cast::<i32>() = _rt::as_i32(equipped_armor2);
                    *ptr1.add(8).cast::<i32>() = _rt::as_i32(item_count2);
                    *ptr1.add(12).cast::<i32>() = _rt::as_i32(max_capacity2);
                    *ptr1.add(16).cast::<i32>() = _rt::as_i32(gold2);
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_add_item_cabi<T: Guest>(
                    arg0: i32,
                    arg1: i32,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                    arg5: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::add_item(
                        super::super::super::super::exports::docs::inventory::types::InventoryState {
                            equipped_weapon: arg0 as u32,
                            equipped_armor: arg1 as u32,
                            item_count: arg2 as u32,
                            max_capacity: arg3 as u32,
                            gold: arg4 as u32,
                        },
                        arg5 as u32,
                    );
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let super::super::super::super::exports::docs::inventory::types::InventoryState {
                        equipped_weapon: equipped_weapon2,
                        equipped_armor: equipped_armor2,
                        item_count: item_count2,
                        max_capacity: max_capacity2,
                        gold: gold2,
                    } = result0;
                    *ptr1.add(0).cast::<i32>() = _rt::as_i32(equipped_weapon2);
                    *ptr1.add(4).cast::<i32>() = _rt::as_i32(equipped_armor2);
                    *ptr1.add(8).cast::<i32>() = _rt::as_i32(item_count2);
                    *ptr1.add(12).cast::<i32>() = _rt::as_i32(max_capacity2);
                    *ptr1.add(16).cast::<i32>() = _rt::as_i32(gold2);
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_remove_item_cabi<T: Guest>(
                    arg0: i32,
                    arg1: i32,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                    arg5: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::remove_item(
                        super::super::super::super::exports::docs::inventory::types::InventoryState {
                            equipped_weapon: arg0 as u32,
                            equipped_armor: arg1 as u32,
                            item_count: arg2 as u32,
                            max_capacity: arg3 as u32,
                            gold: arg4 as u32,
                        },
                        arg5 as u32,
                    );
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let super::super::super::super::exports::docs::inventory::types::InventoryState {
                        equipped_weapon: equipped_weapon2,
                        equipped_armor: equipped_armor2,
                        item_count: item_count2,
                        max_capacity: max_capacity2,
                        gold: gold2,
                    } = result0;
                    *ptr1.add(0).cast::<i32>() = _rt::as_i32(equipped_weapon2);
                    *ptr1.add(4).cast::<i32>() = _rt::as_i32(equipped_armor2);
                    *ptr1.add(8).cast::<i32>() = _rt::as_i32(item_count2);
                    *ptr1.add(12).cast::<i32>() = _rt::as_i32(max_capacity2);
                    *ptr1.add(16).cast::<i32>() = _rt::as_i32(gold2);
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_equip_weapon_cabi<T: Guest>(
                    arg0: i32,
                    arg1: i32,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                    arg5: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::equip_weapon(
                        super::super::super::super::exports::docs::inventory::types::InventoryState {
                            equipped_weapon: arg0 as u32,
                            equipped_armor: arg1 as u32,
                            item_count: arg2 as u32,
                            max_capacity: arg3 as u32,
                            gold: arg4 as u32,
                        },
                        arg5 as u32,
                    );
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let super::super::super::super::exports::docs::inventory::types::InventoryState {
                        equipped_weapon: equipped_weapon2,
                        equipped_armor: equipped_armor2,
                        item_count: item_count2,
                        max_capacity: max_capacity2,
                        gold: gold2,
                    } = result0;
                    *ptr1.add(0).cast::<i32>() = _rt::as_i32(equipped_weapon2);
                    *ptr1.add(4).cast::<i32>() = _rt::as_i32(equipped_armor2);
                    *ptr1.add(8).cast::<i32>() = _rt::as_i32(item_count2);
                    *ptr1.add(12).cast::<i32>() = _rt::as_i32(max_capacity2);
                    *ptr1.add(16).cast::<i32>() = _rt::as_i32(gold2);
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_equip_armor_cabi<T: Guest>(
                    arg0: i32,
                    arg1: i32,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                    arg5: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::equip_armor(
                        super::super::super::super::exports::docs::inventory::types::InventoryState {
                            equipped_weapon: arg0 as u32,
                            equipped_armor: arg1 as u32,
                            item_count: arg2 as u32,
                            max_capacity: arg3 as u32,
                            gold: arg4 as u32,
                        },
                        arg5 as u32,
                    );
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let super::super::super::super::exports::docs::inventory::types::InventoryState {
                        equipped_weapon: equipped_weapon2,
                        equipped_armor: equipped_armor2,
                        item_count: item_count2,
                        max_capacity: max_capacity2,
                        gold: gold2,
                    } = result0;
                    *ptr1.add(0).cast::<i32>() = _rt::as_i32(equipped_weapon2);
                    *ptr1.add(4).cast::<i32>() = _rt::as_i32(equipped_armor2);
                    *ptr1.add(8).cast::<i32>() = _rt::as_i32(item_count2);
                    *ptr1.add(12).cast::<i32>() = _rt::as_i32(max_capacity2);
                    *ptr1.add(16).cast::<i32>() = _rt::as_i32(gold2);
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_add_gold_cabi<T: Guest>(
                    arg0: i32,
                    arg1: i32,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                    arg5: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::add_gold(
                        super::super::super::super::exports::docs::inventory::types::InventoryState {
                            equipped_weapon: arg0 as u32,
                            equipped_armor: arg1 as u32,
                            item_count: arg2 as u32,
                            max_capacity: arg3 as u32,
                            gold: arg4 as u32,
                        },
                        arg5 as u32,
                    );
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let super::super::super::super::exports::docs::inventory::types::InventoryState {
                        equipped_weapon: equipped_weapon2,
                        equipped_armor: equipped_armor2,
                        item_count: item_count2,
                        max_capacity: max_capacity2,
                        gold: gold2,
                    } = result0;
                    *ptr1.add(0).cast::<i32>() = _rt::as_i32(equipped_weapon2);
                    *ptr1.add(4).cast::<i32>() = _rt::as_i32(equipped_armor2);
                    *ptr1.add(8).cast::<i32>() = _rt::as_i32(item_count2);
                    *ptr1.add(12).cast::<i32>() = _rt::as_i32(max_capacity2);
                    *ptr1.add(16).cast::<i32>() = _rt::as_i32(gold2);
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_spend_gold_cabi<T: Guest>(
                    arg0: i32,
                    arg1: i32,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                    arg5: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::spend_gold(
                        super::super::super::super::exports::docs::inventory::types::InventoryState {
                            equipped_weapon: arg0 as u32,
                            equipped_armor: arg1 as u32,
                            item_count: arg2 as u32,
                            max_capacity: arg3 as u32,
                            gold: arg4 as u32,
                        },
                        arg5 as u32,
                    );
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let super::super::super::super::exports::docs::inventory::types::InventoryState {
                        equipped_weapon: equipped_weapon2,
                        equipped_armor: equipped_armor2,
                        item_count: item_count2,
                        max_capacity: max_capacity2,
                        gold: gold2,
                    } = result0;
                    *ptr1.add(0).cast::<i32>() = _rt::as_i32(equipped_weapon2);
                    *ptr1.add(4).cast::<i32>() = _rt::as_i32(equipped_armor2);
                    *ptr1.add(8).cast::<i32>() = _rt::as_i32(item_count2);
                    *ptr1.add(12).cast::<i32>() = _rt::as_i32(max_capacity2);
                    *ptr1.add(16).cast::<i32>() = _rt::as_i32(gold2);
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_is_full_cabi<T: Guest>(
                    arg0: i32,
                    arg1: i32,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                ) -> i32 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::is_full(super::super::super::super::exports::docs::inventory::types::InventoryState {
                        equipped_weapon: arg0 as u32,
                        equipped_armor: arg1 as u32,
                        item_count: arg2 as u32,
                        max_capacity: arg3 as u32,
                        gold: arg4 as u32,
                    });
                    match result0 {
                        true => 1,
                        false => 0,
                    }
                }
                pub trait Guest {
                    /// Create a new empty inventory.
                    fn create_inventory() -> InventoryState;
                    /// Add an item to the inventory.
                    ///
                    /// Returns updated inventory state and success flag.
                    fn add_item(inv: InventoryState, item_id: u32) -> InventoryState;
                    /// Remove an item from the inventory.
                    fn remove_item(inv: InventoryState, item_id: u32) -> InventoryState;
                    /// Equip a weapon by item ID.
                    fn equip_weapon(inv: InventoryState, item_id: u32) -> InventoryState;
                    /// Equip armor by item ID.
                    fn equip_armor(inv: InventoryState, item_id: u32) -> InventoryState;
                    /// Add gold to the inventory.
                    fn add_gold(inv: InventoryState, amount: u32) -> InventoryState;
                    /// Spend gold from the inventory.
                    ///
                    /// Returns updated state; gold unchanged if insufficient funds.
                    fn spend_gold(inv: InventoryState, amount: u32) -> InventoryState;
                    /// Check if inventory is full.
                    fn is_full(inv: InventoryState) -> bool;
                }
                #[doc(hidden)]
                macro_rules! __export_docs_inventory_management_0_1_0_cabi {
                    ($ty:ident with_types_in $($path_to_types:tt)*) => {
                        const _ : () = { #[unsafe (export_name =
                        "docs:inventory/management@0.1.0#create-inventory")] unsafe
                        extern "C" fn export_create_inventory() -> * mut u8 { unsafe {
                        $($path_to_types)*:: _export_create_inventory_cabi::<$ty > () } }
                        #[unsafe (export_name =
                        "docs:inventory/management@0.1.0#add-item")] unsafe extern "C" fn
                        export_add_item(arg0 : i32, arg1 : i32, arg2 : i32, arg3 : i32,
                        arg4 : i32, arg5 : i32,) -> * mut u8 { unsafe {
                        $($path_to_types)*:: _export_add_item_cabi::<$ty > (arg0, arg1,
                        arg2, arg3, arg4, arg5) } } #[unsafe (export_name =
                        "docs:inventory/management@0.1.0#remove-item")] unsafe extern "C"
                        fn export_remove_item(arg0 : i32, arg1 : i32, arg2 : i32, arg3 :
                        i32, arg4 : i32, arg5 : i32,) -> * mut u8 { unsafe {
                        $($path_to_types)*:: _export_remove_item_cabi::<$ty > (arg0,
                        arg1, arg2, arg3, arg4, arg5) } } #[unsafe (export_name =
                        "docs:inventory/management@0.1.0#equip-weapon")] unsafe extern
                        "C" fn export_equip_weapon(arg0 : i32, arg1 : i32, arg2 : i32,
                        arg3 : i32, arg4 : i32, arg5 : i32,) -> * mut u8 { unsafe {
                        $($path_to_types)*:: _export_equip_weapon_cabi::<$ty > (arg0,
                        arg1, arg2, arg3, arg4, arg5) } } #[unsafe (export_name =
                        "docs:inventory/management@0.1.0#equip-armor")] unsafe extern "C"
                        fn export_equip_armor(arg0 : i32, arg1 : i32, arg2 : i32, arg3 :
                        i32, arg4 : i32, arg5 : i32,) -> * mut u8 { unsafe {
                        $($path_to_types)*:: _export_equip_armor_cabi::<$ty > (arg0,
                        arg1, arg2, arg3, arg4, arg5) } } #[unsafe (export_name =
                        "docs:inventory/management@0.1.0#add-gold")] unsafe extern "C" fn
                        export_add_gold(arg0 : i32, arg1 : i32, arg2 : i32, arg3 : i32,
                        arg4 : i32, arg5 : i32,) -> * mut u8 { unsafe {
                        $($path_to_types)*:: _export_add_gold_cabi::<$ty > (arg0, arg1,
                        arg2, arg3, arg4, arg5) } } #[unsafe (export_name =
                        "docs:inventory/management@0.1.0#spend-gold")] unsafe extern "C"
                        fn export_spend_gold(arg0 : i32, arg1 : i32, arg2 : i32, arg3 :
                        i32, arg4 : i32, arg5 : i32,) -> * mut u8 { unsafe {
                        $($path_to_types)*:: _export_spend_gold_cabi::<$ty > (arg0, arg1,
                        arg2, arg3, arg4, arg5) } } #[unsafe (export_name =
                        "docs:inventory/management@0.1.0#is-full")] unsafe extern "C" fn
                        export_is_full(arg0 : i32, arg1 : i32, arg2 : i32, arg3 : i32,
                        arg4 : i32,) -> i32 { unsafe { $($path_to_types)*::
                        _export_is_full_cabi::<$ty > (arg0, arg1, arg2, arg3, arg4) } }
                        };
                    };
                }
                #[doc(hidden)]
                pub(crate) use __export_docs_inventory_management_0_1_0_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 20]);
                static mut _RET_AREA: _RetArea = _RetArea(
                    [::core::mem::MaybeUninit::uninit(); 20],
                );
            }
            /// Item usage interface.
            #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
            pub mod usage {
                #[used]
                #[doc(hidden)]
                static __FORCE_SECTION_REF: fn() = super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type UseResult = super::super::super::super::exports::docs::inventory::types::UseResult;
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_use_item_cabi<T: Guest>(
                    arg0: i32,
                    arg1: i32,
                    arg2: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::use_item(arg0 as u32, arg1 as u32, arg2 as u32);
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let super::super::super::super::exports::docs::inventory::types::UseResult {
                        success: success2,
                        health_restored: health_restored2,
                        attack_boost: attack_boost2,
                        defense_boost: defense_boost2,
                        message: message2,
                    } = result0;
                    *ptr1.add(0).cast::<u8>() = (match success2 {
                        true => 1,
                        false => 0,
                    }) as u8;
                    *ptr1.add(4).cast::<i32>() = _rt::as_i32(health_restored2);
                    *ptr1.add(8).cast::<i32>() = _rt::as_i32(attack_boost2);
                    *ptr1.add(12).cast::<i32>() = _rt::as_i32(defense_boost2);
                    let vec3 = (message2.into_bytes()).into_boxed_slice();
                    let ptr3 = vec3.as_ptr().cast::<u8>();
                    let len3 = vec3.len();
                    ::core::mem::forget(vec3);
                    *ptr1
                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>() = len3;
                    *ptr1.add(16).cast::<*mut u8>() = ptr3.cast_mut();
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_use_item<T: Guest>(arg0: *mut u8) {
                    let l0 = *arg0.add(16).cast::<*mut u8>();
                    let l1 = *arg0
                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    _rt::cabi_dealloc(l0, l1, 1);
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_get_total_attack_bonus_cabi<T: Guest>(
                    arg0: i32,
                ) -> i32 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::get_total_attack_bonus(arg0 as u32);
                    _rt::as_i32(result0)
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_get_total_defense_bonus_cabi<T: Guest>(
                    arg0: i32,
                ) -> i32 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::get_total_defense_bonus(arg0 as u32);
                    _rt::as_i32(result0)
                }
                pub trait Guest {
                    /// Use a consumable item.
                    ///
                    /// Returns the result of using the item.
                    fn use_item(
                        item_id: u32,
                        current_health: u32,
                        max_health: u32,
                    ) -> UseResult;
                    /// Get the total attack bonus from equipped items.
                    fn get_total_attack_bonus(weapon_id: u32) -> u32;
                    /// Get the total defense bonus from equipped items.
                    fn get_total_defense_bonus(armor_id: u32) -> u32;
                }
                #[doc(hidden)]
                macro_rules! __export_docs_inventory_usage_0_1_0_cabi {
                    ($ty:ident with_types_in $($path_to_types:tt)*) => {
                        const _ : () = { #[unsafe (export_name =
                        "docs:inventory/usage@0.1.0#use-item")] unsafe extern "C" fn
                        export_use_item(arg0 : i32, arg1 : i32, arg2 : i32,) -> * mut u8
                        { unsafe { $($path_to_types)*:: _export_use_item_cabi::<$ty >
                        (arg0, arg1, arg2) } } #[unsafe (export_name =
                        "cabi_post_docs:inventory/usage@0.1.0#use-item")] unsafe extern
                        "C" fn _post_return_use_item(arg0 : * mut u8,) { unsafe {
                        $($path_to_types)*:: __post_return_use_item::<$ty > (arg0) } }
                        #[unsafe (export_name =
                        "docs:inventory/usage@0.1.0#get-total-attack-bonus")] unsafe
                        extern "C" fn export_get_total_attack_bonus(arg0 : i32,) -> i32 {
                        unsafe { $($path_to_types)*::
                        _export_get_total_attack_bonus_cabi::<$ty > (arg0) } } #[unsafe
                        (export_name =
                        "docs:inventory/usage@0.1.0#get-total-defense-bonus")] unsafe
                        extern "C" fn export_get_total_defense_bonus(arg0 : i32,) -> i32
                        { unsafe { $($path_to_types)*::
                        _export_get_total_defense_bonus_cabi::<$ty > (arg0) } } };
                    };
                }
                #[doc(hidden)]
                pub(crate) use __export_docs_inventory_usage_0_1_0_cabi;
                #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                struct _RetArea(
                    [::core::mem::MaybeUninit<
                        u8,
                    >; 16 + 2 * ::core::mem::size_of::<*const u8>()],
                );
                static mut _RET_AREA: _RetArea = _RetArea(
                    [::core::mem::MaybeUninit::uninit(); 16
                        + 2 * ::core::mem::size_of::<*const u8>()],
                );
            }
        }
    }
}
#[rustfmt::skip]
mod _rt {
    #![allow(dead_code, clippy::all)]
    pub use alloc_crate::string::String;
    #[cfg(target_arch = "wasm32")]
    pub fn run_ctors_once() {
        wit_bindgen_rt::run_ctors_once();
    }
    pub fn as_i32<T: AsI32>(t: T) -> i32 {
        t.as_i32()
    }
    pub trait AsI32 {
        fn as_i32(self) -> i32;
    }
    impl<'a, T: Copy + AsI32> AsI32 for &'a T {
        fn as_i32(self) -> i32 {
            (*self).as_i32()
        }
    }
    impl AsI32 for i32 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for u32 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for i16 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for u16 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for i8 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for u8 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for char {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for usize {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    pub unsafe fn cabi_dealloc(ptr: *mut u8, size: usize, align: usize) {
        if size == 0 {
            return;
        }
        let layout = alloc::Layout::from_size_align_unchecked(size, align);
        alloc::dealloc(ptr, layout);
    }
    extern crate alloc as alloc_crate;
    pub use alloc_crate::alloc;
}
/// Generates `#[unsafe(no_mangle)]` functions to export the specified type as
/// the root implementation of all generated traits.
///
/// For more information see the documentation of `wit_bindgen::generate!`.
///
/// ```rust
/// # macro_rules! export{ ($($t:tt)*) => (); }
/// # trait Guest {}
/// struct MyType;
///
/// impl Guest for MyType {
///     // ...
/// }
///
/// export!(MyType);
/// ```
#[allow(unused_macros)]
#[doc(hidden)]
macro_rules! __export_inventory_impl {
    ($ty:ident) => {
        self::export!($ty with_types_in self);
    };
    ($ty:ident with_types_in $($path_to_types_root:tt)*) => {
        $($path_to_types_root)*::
        exports::docs::inventory::types::__export_docs_inventory_types_0_1_0_cabi!($ty
        with_types_in $($path_to_types_root)*:: exports::docs::inventory::types);
        $($path_to_types_root)*::
        exports::docs::inventory::items::__export_docs_inventory_items_0_1_0_cabi!($ty
        with_types_in $($path_to_types_root)*:: exports::docs::inventory::items);
        $($path_to_types_root)*::
        exports::docs::inventory::management::__export_docs_inventory_management_0_1_0_cabi!($ty
        with_types_in $($path_to_types_root)*:: exports::docs::inventory::management);
        $($path_to_types_root)*::
        exports::docs::inventory::usage::__export_docs_inventory_usage_0_1_0_cabi!($ty
        with_types_in $($path_to_types_root)*:: exports::docs::inventory::usage);
    };
}
#[doc(inline)]
pub(crate) use __export_inventory_impl as export;
#[cfg(target_arch = "wasm32")]
#[unsafe(
    link_section = "component-type:wit-bindgen:0.41.0:docs:inventory@0.1.0:inventory:encoded world"
)]
#[doc(hidden)]
#[allow(clippy::octal_escapes)]
pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 1581] = *b"\
\0asm\x0d\0\x01\0\0\x19\x16wit-component-encoding\x04\0\x07\xad\x0b\x01A\x02\x01\
A\x0e\x01B\x0e\x01m\x05\x06weapon\x05armor\x0aconsumable\x08key-item\x08treasure\
\x04\0\x0ditem-category\x03\0\0\x01m\x05\x0cwooden-sword\x0bsteel-sword\x0cmaste\
r-sword\x03bow\x08fire-rod\x04\0\x0bweapon-type\x03\0\x02\x01m\x05\x0bcloth-tuni\
c\x0dleather-armor\x0achain-mail\x06shield\x0amagic-robe\x04\0\x0aarmor-type\x03\
\0\x04\x01m\x05\x0dhealth-potion\x12full-health-potion\x0cattack-boost\x0ddefens\
e-boost\x08antidote\x04\0\x0fconsumable-type\x03\0\x06\x01r\x08\x02idy\x04names\x08\
category\x01\x0cattack-bonusy\x0ddefense-bonusy\x0bheal-amounty\x08quantityy\x0b\
is-equipped\x7f\x04\0\x04item\x03\0\x08\x01r\x05\x0fequipped-weapony\x0eequipped\
-armory\x0aitem-county\x0cmax-capacityy\x04goldy\x04\0\x0finventory-state\x03\0\x0a\
\x01r\x05\x07success\x7f\x0fhealth-restoredy\x0cattack-boosty\x0ddefense-boosty\x07\
messages\x04\0\x0ause-result\x03\0\x0c\x04\0\x1adocs:inventory/types@0.1.0\x05\0\
\x02\x03\0\0\x04item\x02\x03\0\0\x0bweapon-type\x02\x03\0\0\x0aarmor-type\x02\x03\
\0\0\x0fconsumable-type\x01B\x10\x02\x03\x02\x01\x01\x04\0\x04item\x03\0\0\x02\x03\
\x02\x01\x02\x04\0\x0bweapon-type\x03\0\x02\x02\x03\x02\x01\x03\x04\0\x0aarmor-t\
ype\x03\0\x04\x02\x03\x02\x01\x04\x04\0\x0fconsumable-type\x03\0\x06\x01@\x01\x06\
weapon\x03\0\x01\x04\0\x0dcreate-weapon\x01\x08\x01@\x01\x05armor\x05\0\x01\x04\0\
\x0ccreate-armor\x01\x09\x01@\x02\x0aconsumable\x07\x08quantityy\0\x01\x04\0\x11\
create-consumable\x01\x0a\x01@\x01\x07item-idy\0\x01\x04\0\x0eget-item-stats\x01\
\x0b\x04\0\x1adocs:inventory/items@0.1.0\x05\x05\x02\x03\0\0\x0finventory-state\x01\
B\x10\x02\x03\x02\x01\x06\x04\0\x0finventory-state\x03\0\0\x02\x03\x02\x01\x01\x04\
\0\x04item\x03\0\x02\x01@\0\0\x01\x04\0\x10create-inventory\x01\x04\x01@\x02\x03\
inv\x01\x07item-idy\0\x01\x04\0\x08add-item\x01\x05\x04\0\x0bremove-item\x01\x05\
\x04\0\x0cequip-weapon\x01\x05\x04\0\x0bequip-armor\x01\x05\x01@\x02\x03inv\x01\x06\
amounty\0\x01\x04\0\x08add-gold\x01\x06\x04\0\x0aspend-gold\x01\x06\x01@\x01\x03\
inv\x01\0\x7f\x04\0\x07is-full\x01\x07\x04\0\x1fdocs:inventory/management@0.1.0\x05\
\x07\x02\x03\0\0\x0ause-result\x01B\x08\x02\x03\x02\x01\x08\x04\0\x0ause-result\x03\
\0\0\x01@\x03\x07item-idy\x0ecurrent-healthy\x0amax-healthy\0\x01\x04\0\x08use-i\
tem\x01\x02\x01@\x01\x09weapon-idy\0y\x04\0\x16get-total-attack-bonus\x01\x03\x01\
@\x01\x08armor-idy\0y\x04\0\x17get-total-defense-bonus\x01\x04\x04\0\x1adocs:inv\
entory/usage@0.1.0\x05\x09\x04\0\x1edocs:inventory/inventory@0.1.0\x04\0\x0b\x0f\
\x01\0\x09inventory\x03\0\0\0G\x09producers\x01\x0cprocessed-by\x02\x0dwit-compo\
nent\x070.227.1\x10wit-bindgen-rust\x060.41.0";
#[inline(never)]
#[doc(hidden)]
pub fn __link_custom_section_describing_imports() {
    wit_bindgen_rt::maybe_link_cabi_realloc();
}
