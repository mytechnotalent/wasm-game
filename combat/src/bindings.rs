// Generated by `wit-bindgen` 0.41.0. DO NOT EDIT!
// Options used:
//   * runtime_path: "wit_bindgen_rt"
#[rustfmt::skip]
#[allow(dead_code, clippy::all)]
pub mod exports {
    pub mod docs {
        pub mod combat {
            /// Combat type definitions and data structures.
            #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
            pub mod types {
                #[used]
                #[doc(hidden)]
                static __FORCE_SECTION_REF: fn() = super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                /// Types of attacks available.
                #[repr(u8)]
                #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
                pub enum AttackType {
                    /// Basic sword slash.
                    SwordSlash,
                    /// Charged spin attack.
                    SpinAttack,
                    /// Ranged bow shot.
                    BowShot,
                    /// Magic spell attack.
                    MagicAttack,
                    /// Shield bash (stuns enemies).
                    ShieldBash,
                }
                impl ::core::fmt::Debug for AttackType {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        match self {
                            AttackType::SwordSlash => {
                                f.debug_tuple("AttackType::SwordSlash").finish()
                            }
                            AttackType::SpinAttack => {
                                f.debug_tuple("AttackType::SpinAttack").finish()
                            }
                            AttackType::BowShot => {
                                f.debug_tuple("AttackType::BowShot").finish()
                            }
                            AttackType::MagicAttack => {
                                f.debug_tuple("AttackType::MagicAttack").finish()
                            }
                            AttackType::ShieldBash => {
                                f.debug_tuple("AttackType::ShieldBash").finish()
                            }
                        }
                    }
                }
                impl AttackType {
                    #[doc(hidden)]
                    pub unsafe fn _lift(val: u8) -> AttackType {
                        if !cfg!(debug_assertions) {
                            return ::core::mem::transmute(val);
                        }
                        match val {
                            0 => AttackType::SwordSlash,
                            1 => AttackType::SpinAttack,
                            2 => AttackType::BowShot,
                            3 => AttackType::MagicAttack,
                            4 => AttackType::ShieldBash,
                            _ => panic!("invalid enum discriminant"),
                        }
                    }
                }
                /// Result of a combat action.
                #[derive(Clone)]
                pub struct CombatResult {
                    /// Damage dealt to the target.
                    pub damage_dealt: u32,
                    /// Whether the attack was a critical hit.
                    pub is_critical: bool,
                    /// Whether the target was defeated.
                    pub target_defeated: bool,
                    /// Experience gained (if enemy defeated).
                    pub exp_gained: u32,
                    /// Combat message/description.
                    pub message: _rt::String,
                }
                impl ::core::fmt::Debug for CombatResult {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("CombatResult")
                            .field("damage-dealt", &self.damage_dealt)
                            .field("is-critical", &self.is_critical)
                            .field("target-defeated", &self.target_defeated)
                            .field("exp-gained", &self.exp_gained)
                            .field("message", &self.message)
                            .finish()
                    }
                }
                /// Combat statistics for damage calculation.
                #[repr(C)]
                #[derive(Clone, Copy)]
                pub struct CombatantStats {
                    /// Base attack power.
                    pub attack: u32,
                    /// Defense rating.
                    pub defense: u32,
                    /// Current health.
                    pub health: u32,
                    /// Maximum health.
                    pub max_health: u32,
                    /// Bonus from equipment.
                    pub equipment_bonus: u32,
                }
                impl ::core::fmt::Debug for CombatantStats {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("CombatantStats")
                            .field("attack", &self.attack)
                            .field("defense", &self.defense)
                            .field("health", &self.health)
                            .field("max-health", &self.max_health)
                            .field("equipment-bonus", &self.equipment_bonus)
                            .finish()
                    }
                }
                /// Battle state tracking.
                #[repr(C)]
                #[derive(Clone, Copy)]
                pub struct BattleState {
                    /// Whether a battle is currently active.
                    pub is_active: bool,
                    /// Current turn number.
                    pub turn_count: u32,
                    /// Player's remaining health.
                    pub player_health: u32,
                    /// Enemy's remaining health.
                    pub enemy_health: u32,
                    /// Whether it's the player's turn.
                    pub is_player_turn: bool,
                }
                impl ::core::fmt::Debug for BattleState {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("BattleState")
                            .field("is-active", &self.is_active)
                            .field("turn-count", &self.turn_count)
                            .field("player-health", &self.player_health)
                            .field("enemy-health", &self.enemy_health)
                            .field("is-player-turn", &self.is_player_turn)
                            .finish()
                    }
                }
                #[doc(hidden)]
                macro_rules! __export_docs_combat_types_0_1_0_cabi {
                    ($ty:ident with_types_in $($path_to_types:tt)*) => {
                        const _ : () = {};
                    };
                }
                #[doc(hidden)]
                pub(crate) use __export_docs_combat_types_0_1_0_cabi;
            }
            /// Damage calculation interface.
            #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
            pub mod damage {
                #[used]
                #[doc(hidden)]
                static __FORCE_SECTION_REF: fn() = super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type AttackType = super::super::super::super::exports::docs::combat::types::AttackType;
                pub type CombatantStats = super::super::super::super::exports::docs::combat::types::CombatantStats;
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_calculate_base_damage_cabi<T: Guest>(
                    arg0: i32,
                    arg1: i32,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                    arg5: i32,
                ) -> i32 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::calculate_base_damage(
                        super::super::super::super::exports::docs::combat::types::AttackType::_lift(
                            arg0 as u8,
                        ),
                        super::super::super::super::exports::docs::combat::types::CombatantStats {
                            attack: arg1 as u32,
                            defense: arg2 as u32,
                            health: arg3 as u32,
                            max_health: arg4 as u32,
                            equipment_bonus: arg5 as u32,
                        },
                    );
                    _rt::as_i32(result0)
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_apply_defense_cabi<T: Guest>(
                    arg0: i32,
                    arg1: i32,
                ) -> i32 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::apply_defense(arg0 as u32, arg1 as u32);
                    _rt::as_i32(result0)
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_roll_critical_cabi<T: Guest>(arg0: i32) -> i32 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::roll_critical(arg0 as u32);
                    _rt::as_i32(result0)
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_apply_critical_cabi<T: Guest>(
                    arg0: i32,
                    arg1: i32,
                ) -> i32 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::apply_critical(arg0 as u32, arg1 as u32);
                    _rt::as_i32(result0)
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_calculate_final_damage_cabi<T: Guest>(
                    arg0: i32,
                    arg1: i32,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                    arg5: i32,
                    arg6: i32,
                    arg7: i32,
                    arg8: i32,
                    arg9: i32,
                    arg10: i32,
                ) -> i32 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::calculate_final_damage(
                        super::super::super::super::exports::docs::combat::types::AttackType::_lift(
                            arg0 as u8,
                        ),
                        super::super::super::super::exports::docs::combat::types::CombatantStats {
                            attack: arg1 as u32,
                            defense: arg2 as u32,
                            health: arg3 as u32,
                            max_health: arg4 as u32,
                            equipment_bonus: arg5 as u32,
                        },
                        super::super::super::super::exports::docs::combat::types::CombatantStats {
                            attack: arg6 as u32,
                            defense: arg7 as u32,
                            health: arg8 as u32,
                            max_health: arg9 as u32,
                            equipment_bonus: arg10 as u32,
                        },
                    );
                    _rt::as_i32(result0)
                }
                pub trait Guest {
                    /// Calculate base damage for an attack type.
                    fn calculate_base_damage(
                        attack: AttackType,
                        attacker_stats: CombatantStats,
                    ) -> u32;
                    /// Apply defense reduction to damage.
                    fn apply_defense(raw_damage: u32, defender_defense: u32) -> u32;
                    /// Calculate critical hit chance (returns 1 for crit, 0 for normal).
                    fn roll_critical(attacker_attack: u32) -> u32;
                    /// Apply critical hit multiplier if applicable.
                    fn apply_critical(damage: u32, is_critical: u32) -> u32;
                    /// Calculate final damage with all modifiers.
                    fn calculate_final_damage(
                        attack: AttackType,
                        attacker: CombatantStats,
                        defender: CombatantStats,
                    ) -> u32;
                }
                #[doc(hidden)]
                macro_rules! __export_docs_combat_damage_0_1_0_cabi {
                    ($ty:ident with_types_in $($path_to_types:tt)*) => {
                        const _ : () = { #[unsafe (export_name =
                        "docs:combat/damage@0.1.0#calculate-base-damage")] unsafe extern
                        "C" fn export_calculate_base_damage(arg0 : i32, arg1 : i32, arg2
                        : i32, arg3 : i32, arg4 : i32, arg5 : i32,) -> i32 { unsafe {
                        $($path_to_types)*:: _export_calculate_base_damage_cabi::<$ty >
                        (arg0, arg1, arg2, arg3, arg4, arg5) } } #[unsafe (export_name =
                        "docs:combat/damage@0.1.0#apply-defense")] unsafe extern "C" fn
                        export_apply_defense(arg0 : i32, arg1 : i32,) -> i32 { unsafe {
                        $($path_to_types)*:: _export_apply_defense_cabi::<$ty > (arg0,
                        arg1) } } #[unsafe (export_name =
                        "docs:combat/damage@0.1.0#roll-critical")] unsafe extern "C" fn
                        export_roll_critical(arg0 : i32,) -> i32 { unsafe {
                        $($path_to_types)*:: _export_roll_critical_cabi::<$ty > (arg0) }
                        } #[unsafe (export_name =
                        "docs:combat/damage@0.1.0#apply-critical")] unsafe extern "C" fn
                        export_apply_critical(arg0 : i32, arg1 : i32,) -> i32 { unsafe {
                        $($path_to_types)*:: _export_apply_critical_cabi::<$ty > (arg0,
                        arg1) } } #[unsafe (export_name =
                        "docs:combat/damage@0.1.0#calculate-final-damage")] unsafe extern
                        "C" fn export_calculate_final_damage(arg0 : i32, arg1 : i32, arg2
                        : i32, arg3 : i32, arg4 : i32, arg5 : i32, arg6 : i32, arg7 :
                        i32, arg8 : i32, arg9 : i32, arg10 : i32,) -> i32 { unsafe {
                        $($path_to_types)*:: _export_calculate_final_damage_cabi::<$ty >
                        (arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9,
                        arg10) } } };
                    };
                }
                #[doc(hidden)]
                pub(crate) use __export_docs_combat_damage_0_1_0_cabi;
            }
            /// Combat action interface.
            #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
            pub mod actions {
                #[used]
                #[doc(hidden)]
                static __FORCE_SECTION_REF: fn() = super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type AttackType = super::super::super::super::exports::docs::combat::types::AttackType;
                pub type CombatResult = super::super::super::super::exports::docs::combat::types::CombatResult;
                pub type CombatantStats = super::super::super::super::exports::docs::combat::types::CombatantStats;
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_player_attack_cabi<T: Guest>(
                    arg0: i32,
                    arg1: i32,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                    arg5: i32,
                    arg6: i32,
                    arg7: i32,
                    arg8: i32,
                    arg9: i32,
                    arg10: i32,
                    arg11: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::player_attack(
                        super::super::super::super::exports::docs::combat::types::AttackType::_lift(
                            arg0 as u8,
                        ),
                        super::super::super::super::exports::docs::combat::types::CombatantStats {
                            attack: arg1 as u32,
                            defense: arg2 as u32,
                            health: arg3 as u32,
                            max_health: arg4 as u32,
                            equipment_bonus: arg5 as u32,
                        },
                        super::super::super::super::exports::docs::combat::types::CombatantStats {
                            attack: arg6 as u32,
                            defense: arg7 as u32,
                            health: arg8 as u32,
                            max_health: arg9 as u32,
                            equipment_bonus: arg10 as u32,
                        },
                        arg11 as u32,
                    );
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let super::super::super::super::exports::docs::combat::types::CombatResult {
                        damage_dealt: damage_dealt2,
                        is_critical: is_critical2,
                        target_defeated: target_defeated2,
                        exp_gained: exp_gained2,
                        message: message2,
                    } = result0;
                    *ptr1.add(0).cast::<i32>() = _rt::as_i32(damage_dealt2);
                    *ptr1.add(4).cast::<u8>() = (match is_critical2 {
                        true => 1,
                        false => 0,
                    }) as u8;
                    *ptr1.add(5).cast::<u8>() = (match target_defeated2 {
                        true => 1,
                        false => 0,
                    }) as u8;
                    *ptr1.add(8).cast::<i32>() = _rt::as_i32(exp_gained2);
                    let vec3 = (message2.into_bytes()).into_boxed_slice();
                    let ptr3 = vec3.as_ptr().cast::<u8>();
                    let len3 = vec3.len();
                    ::core::mem::forget(vec3);
                    *ptr1
                        .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>() = len3;
                    *ptr1
                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>() = ptr3.cast_mut();
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_player_attack<T: Guest>(arg0: *mut u8) {
                    let l0 = *arg0
                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l1 = *arg0
                        .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    _rt::cabi_dealloc(l0, l1, 1);
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_enemy_attack_cabi<T: Guest>(
                    arg0: i32,
                    arg1: i32,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                    arg5: i32,
                    arg6: i32,
                    arg7: i32,
                    arg8: i32,
                    arg9: i32,
                    arg10: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::enemy_attack(
                        arg0 as u32,
                        super::super::super::super::exports::docs::combat::types::CombatantStats {
                            attack: arg1 as u32,
                            defense: arg2 as u32,
                            health: arg3 as u32,
                            max_health: arg4 as u32,
                            equipment_bonus: arg5 as u32,
                        },
                        super::super::super::super::exports::docs::combat::types::CombatantStats {
                            attack: arg6 as u32,
                            defense: arg7 as u32,
                            health: arg8 as u32,
                            max_health: arg9 as u32,
                            equipment_bonus: arg10 as u32,
                        },
                    );
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let super::super::super::super::exports::docs::combat::types::CombatResult {
                        damage_dealt: damage_dealt2,
                        is_critical: is_critical2,
                        target_defeated: target_defeated2,
                        exp_gained: exp_gained2,
                        message: message2,
                    } = result0;
                    *ptr1.add(0).cast::<i32>() = _rt::as_i32(damage_dealt2);
                    *ptr1.add(4).cast::<u8>() = (match is_critical2 {
                        true => 1,
                        false => 0,
                    }) as u8;
                    *ptr1.add(5).cast::<u8>() = (match target_defeated2 {
                        true => 1,
                        false => 0,
                    }) as u8;
                    *ptr1.add(8).cast::<i32>() = _rt::as_i32(exp_gained2);
                    let vec3 = (message2.into_bytes()).into_boxed_slice();
                    let ptr3 = vec3.as_ptr().cast::<u8>();
                    let len3 = vec3.len();
                    ::core::mem::forget(vec3);
                    *ptr1
                        .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>() = len3;
                    *ptr1
                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>() = ptr3.cast_mut();
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_enemy_attack<T: Guest>(arg0: *mut u8) {
                    let l0 = *arg0
                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l1 = *arg0
                        .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    _rt::cabi_dealloc(l0, l1, 1);
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_can_special_attack_cabi<T: Guest>(
                    arg0: i32,
                    arg1: i32,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                    arg5: i32,
                ) -> i32 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::can_special_attack(
                        super::super::super::super::exports::docs::combat::types::AttackType::_lift(
                            arg0 as u8,
                        ),
                        super::super::super::super::exports::docs::combat::types::CombatantStats {
                            attack: arg1 as u32,
                            defense: arg2 as u32,
                            health: arg3 as u32,
                            max_health: arg4 as u32,
                            equipment_bonus: arg5 as u32,
                        },
                    );
                    match result0 {
                        true => 1,
                        false => 0,
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_attempt_flee_cabi<T: Guest>(
                    arg0: i32,
                    arg1: i32,
                ) -> i32 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::attempt_flee(arg0 as u32, arg1 as u32);
                    match result0 {
                        true => 1,
                        false => 0,
                    }
                }
                pub trait Guest {
                    /// Execute a player attack against an enemy.
                    fn player_attack(
                        attack: AttackType,
                        player_stats: CombatantStats,
                        enemy_stats: CombatantStats,
                        enemy_exp: u32,
                    ) -> CombatResult;
                    /// Execute an enemy attack against the player.
                    fn enemy_attack(
                        enemy_attack: u32,
                        enemy_stats: CombatantStats,
                        player_stats: CombatantStats,
                    ) -> CombatResult;
                    /// Check if the player can perform a special attack.
                    fn can_special_attack(
                        attack: AttackType,
                        player_stats: CombatantStats,
                    ) -> bool;
                    /// Attempt to flee from combat.
                    ///
                    /// Returns true if escape was successful.
                    fn attempt_flee(player_speed: u32, enemy_speed: u32) -> bool;
                }
                #[doc(hidden)]
                macro_rules! __export_docs_combat_actions_0_1_0_cabi {
                    ($ty:ident with_types_in $($path_to_types:tt)*) => {
                        const _ : () = { #[unsafe (export_name =
                        "docs:combat/actions@0.1.0#player-attack")] unsafe extern "C" fn
                        export_player_attack(arg0 : i32, arg1 : i32, arg2 : i32, arg3 :
                        i32, arg4 : i32, arg5 : i32, arg6 : i32, arg7 : i32, arg8 : i32,
                        arg9 : i32, arg10 : i32, arg11 : i32,) -> * mut u8 { unsafe {
                        $($path_to_types)*:: _export_player_attack_cabi::<$ty > (arg0,
                        arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10,
                        arg11) } } #[unsafe (export_name =
                        "cabi_post_docs:combat/actions@0.1.0#player-attack")] unsafe
                        extern "C" fn _post_return_player_attack(arg0 : * mut u8,) {
                        unsafe { $($path_to_types)*:: __post_return_player_attack::<$ty >
                        (arg0) } } #[unsafe (export_name =
                        "docs:combat/actions@0.1.0#enemy-attack")] unsafe extern "C" fn
                        export_enemy_attack(arg0 : i32, arg1 : i32, arg2 : i32, arg3 :
                        i32, arg4 : i32, arg5 : i32, arg6 : i32, arg7 : i32, arg8 : i32,
                        arg9 : i32, arg10 : i32,) -> * mut u8 { unsafe {
                        $($path_to_types)*:: _export_enemy_attack_cabi::<$ty > (arg0,
                        arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10) } }
                        #[unsafe (export_name =
                        "cabi_post_docs:combat/actions@0.1.0#enemy-attack")] unsafe
                        extern "C" fn _post_return_enemy_attack(arg0 : * mut u8,) {
                        unsafe { $($path_to_types)*:: __post_return_enemy_attack::<$ty >
                        (arg0) } } #[unsafe (export_name =
                        "docs:combat/actions@0.1.0#can-special-attack")] unsafe extern
                        "C" fn export_can_special_attack(arg0 : i32, arg1 : i32, arg2 :
                        i32, arg3 : i32, arg4 : i32, arg5 : i32,) -> i32 { unsafe {
                        $($path_to_types)*:: _export_can_special_attack_cabi::<$ty >
                        (arg0, arg1, arg2, arg3, arg4, arg5) } } #[unsafe (export_name =
                        "docs:combat/actions@0.1.0#attempt-flee")] unsafe extern "C" fn
                        export_attempt_flee(arg0 : i32, arg1 : i32,) -> i32 { unsafe {
                        $($path_to_types)*:: _export_attempt_flee_cabi::<$ty > (arg0,
                        arg1) } } };
                    };
                }
                #[doc(hidden)]
                pub(crate) use __export_docs_combat_actions_0_1_0_cabi;
                #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                struct _RetArea(
                    [::core::mem::MaybeUninit<
                        u8,
                    >; 8 + 3 * ::core::mem::size_of::<*const u8>()],
                );
                static mut _RET_AREA: _RetArea = _RetArea(
                    [::core::mem::MaybeUninit::uninit(); 8
                        + 3 * ::core::mem::size_of::<*const u8>()],
                );
            }
            /// Battle management interface.
            #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
            pub mod battle {
                #[used]
                #[doc(hidden)]
                static __FORCE_SECTION_REF: fn() = super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type BattleState = super::super::super::super::exports::docs::combat::types::BattleState;
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_start_battle_cabi<T: Guest>(
                    arg0: i32,
                    arg1: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::start_battle(arg0 as u32, arg1 as u32);
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let super::super::super::super::exports::docs::combat::types::BattleState {
                        is_active: is_active2,
                        turn_count: turn_count2,
                        player_health: player_health2,
                        enemy_health: enemy_health2,
                        is_player_turn: is_player_turn2,
                    } = result0;
                    *ptr1.add(0).cast::<u8>() = (match is_active2 {
                        true => 1,
                        false => 0,
                    }) as u8;
                    *ptr1.add(4).cast::<i32>() = _rt::as_i32(turn_count2);
                    *ptr1.add(8).cast::<i32>() = _rt::as_i32(player_health2);
                    *ptr1.add(12).cast::<i32>() = _rt::as_i32(enemy_health2);
                    *ptr1.add(16).cast::<u8>() = (match is_player_turn2 {
                        true => 1,
                        false => 0,
                    }) as u8;
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_end_battle_cabi<T: Guest>(
                    arg0: i32,
                    arg1: i32,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::end_battle(super::super::super::super::exports::docs::combat::types::BattleState {
                        is_active: _rt::bool_lift(arg0 as u8),
                        turn_count: arg1 as u32,
                        player_health: arg2 as u32,
                        enemy_health: arg3 as u32,
                        is_player_turn: _rt::bool_lift(arg4 as u8),
                    });
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let super::super::super::super::exports::docs::combat::types::BattleState {
                        is_active: is_active2,
                        turn_count: turn_count2,
                        player_health: player_health2,
                        enemy_health: enemy_health2,
                        is_player_turn: is_player_turn2,
                    } = result0;
                    *ptr1.add(0).cast::<u8>() = (match is_active2 {
                        true => 1,
                        false => 0,
                    }) as u8;
                    *ptr1.add(4).cast::<i32>() = _rt::as_i32(turn_count2);
                    *ptr1.add(8).cast::<i32>() = _rt::as_i32(player_health2);
                    *ptr1.add(12).cast::<i32>() = _rt::as_i32(enemy_health2);
                    *ptr1.add(16).cast::<u8>() = (match is_player_turn2 {
                        true => 1,
                        false => 0,
                    }) as u8;
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_next_turn_cabi<T: Guest>(
                    arg0: i32,
                    arg1: i32,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::next_turn(super::super::super::super::exports::docs::combat::types::BattleState {
                        is_active: _rt::bool_lift(arg0 as u8),
                        turn_count: arg1 as u32,
                        player_health: arg2 as u32,
                        enemy_health: arg3 as u32,
                        is_player_turn: _rt::bool_lift(arg4 as u8),
                    });
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let super::super::super::super::exports::docs::combat::types::BattleState {
                        is_active: is_active2,
                        turn_count: turn_count2,
                        player_health: player_health2,
                        enemy_health: enemy_health2,
                        is_player_turn: is_player_turn2,
                    } = result0;
                    *ptr1.add(0).cast::<u8>() = (match is_active2 {
                        true => 1,
                        false => 0,
                    }) as u8;
                    *ptr1.add(4).cast::<i32>() = _rt::as_i32(turn_count2);
                    *ptr1.add(8).cast::<i32>() = _rt::as_i32(player_health2);
                    *ptr1.add(12).cast::<i32>() = _rt::as_i32(enemy_health2);
                    *ptr1.add(16).cast::<u8>() = (match is_player_turn2 {
                        true => 1,
                        false => 0,
                    }) as u8;
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_update_health_cabi<T: Guest>(
                    arg0: i32,
                    arg1: i32,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                    arg5: i32,
                    arg6: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::update_health(
                        super::super::super::super::exports::docs::combat::types::BattleState {
                            is_active: _rt::bool_lift(arg0 as u8),
                            turn_count: arg1 as u32,
                            player_health: arg2 as u32,
                            enemy_health: arg3 as u32,
                            is_player_turn: _rt::bool_lift(arg4 as u8),
                        },
                        arg5 as u32,
                        arg6 as u32,
                    );
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let super::super::super::super::exports::docs::combat::types::BattleState {
                        is_active: is_active2,
                        turn_count: turn_count2,
                        player_health: player_health2,
                        enemy_health: enemy_health2,
                        is_player_turn: is_player_turn2,
                    } = result0;
                    *ptr1.add(0).cast::<u8>() = (match is_active2 {
                        true => 1,
                        false => 0,
                    }) as u8;
                    *ptr1.add(4).cast::<i32>() = _rt::as_i32(turn_count2);
                    *ptr1.add(8).cast::<i32>() = _rt::as_i32(player_health2);
                    *ptr1.add(12).cast::<i32>() = _rt::as_i32(enemy_health2);
                    *ptr1.add(16).cast::<u8>() = (match is_player_turn2 {
                        true => 1,
                        false => 0,
                    }) as u8;
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_is_battle_over_cabi<T: Guest>(
                    arg0: i32,
                    arg1: i32,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                ) -> i32 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::is_battle_over(super::super::super::super::exports::docs::combat::types::BattleState {
                        is_active: _rt::bool_lift(arg0 as u8),
                        turn_count: arg1 as u32,
                        player_health: arg2 as u32,
                        enemy_health: arg3 as u32,
                        is_player_turn: _rt::bool_lift(arg4 as u8),
                    });
                    match result0 {
                        true => 1,
                        false => 0,
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_player_won_cabi<T: Guest>(
                    arg0: i32,
                    arg1: i32,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                ) -> i32 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::player_won(super::super::super::super::exports::docs::combat::types::BattleState {
                        is_active: _rt::bool_lift(arg0 as u8),
                        turn_count: arg1 as u32,
                        player_health: arg2 as u32,
                        enemy_health: arg3 as u32,
                        is_player_turn: _rt::bool_lift(arg4 as u8),
                    });
                    match result0 {
                        true => 1,
                        false => 0,
                    }
                }
                pub trait Guest {
                    /// Start a new battle.
                    fn start_battle(
                        player_health: u32,
                        enemy_health: u32,
                    ) -> BattleState;
                    /// End the current battle.
                    fn end_battle(state: BattleState) -> BattleState;
                    /// Advance to the next turn.
                    fn next_turn(state: BattleState) -> BattleState;
                    /// Update battle state after combat action.
                    fn update_health(
                        state: BattleState,
                        player_health: u32,
                        enemy_health: u32,
                    ) -> BattleState;
                    /// Check if the battle is over.
                    fn is_battle_over(state: BattleState) -> bool;
                    /// Determine the battle outcome (true = player won).
                    fn player_won(state: BattleState) -> bool;
                }
                #[doc(hidden)]
                macro_rules! __export_docs_combat_battle_0_1_0_cabi {
                    ($ty:ident with_types_in $($path_to_types:tt)*) => {
                        const _ : () = { #[unsafe (export_name =
                        "docs:combat/battle@0.1.0#start-battle")] unsafe extern "C" fn
                        export_start_battle(arg0 : i32, arg1 : i32,) -> * mut u8 { unsafe
                        { $($path_to_types)*:: _export_start_battle_cabi::<$ty > (arg0,
                        arg1) } } #[unsafe (export_name =
                        "docs:combat/battle@0.1.0#end-battle")] unsafe extern "C" fn
                        export_end_battle(arg0 : i32, arg1 : i32, arg2 : i32, arg3 : i32,
                        arg4 : i32,) -> * mut u8 { unsafe { $($path_to_types)*::
                        _export_end_battle_cabi::<$ty > (arg0, arg1, arg2, arg3, arg4) }
                        } #[unsafe (export_name = "docs:combat/battle@0.1.0#next-turn")]
                        unsafe extern "C" fn export_next_turn(arg0 : i32, arg1 : i32,
                        arg2 : i32, arg3 : i32, arg4 : i32,) -> * mut u8 { unsafe {
                        $($path_to_types)*:: _export_next_turn_cabi::<$ty > (arg0, arg1,
                        arg2, arg3, arg4) } } #[unsafe (export_name =
                        "docs:combat/battle@0.1.0#update-health")] unsafe extern "C" fn
                        export_update_health(arg0 : i32, arg1 : i32, arg2 : i32, arg3 :
                        i32, arg4 : i32, arg5 : i32, arg6 : i32,) -> * mut u8 { unsafe {
                        $($path_to_types)*:: _export_update_health_cabi::<$ty > (arg0,
                        arg1, arg2, arg3, arg4, arg5, arg6) } } #[unsafe (export_name =
                        "docs:combat/battle@0.1.0#is-battle-over")] unsafe extern "C" fn
                        export_is_battle_over(arg0 : i32, arg1 : i32, arg2 : i32, arg3 :
                        i32, arg4 : i32,) -> i32 { unsafe { $($path_to_types)*::
                        _export_is_battle_over_cabi::<$ty > (arg0, arg1, arg2, arg3,
                        arg4) } } #[unsafe (export_name =
                        "docs:combat/battle@0.1.0#player-won")] unsafe extern "C" fn
                        export_player_won(arg0 : i32, arg1 : i32, arg2 : i32, arg3 : i32,
                        arg4 : i32,) -> i32 { unsafe { $($path_to_types)*::
                        _export_player_won_cabi::<$ty > (arg0, arg1, arg2, arg3, arg4) }
                        } };
                    };
                }
                #[doc(hidden)]
                pub(crate) use __export_docs_combat_battle_0_1_0_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 20]);
                static mut _RET_AREA: _RetArea = _RetArea(
                    [::core::mem::MaybeUninit::uninit(); 20],
                );
            }
        }
    }
}
#[rustfmt::skip]
mod _rt {
    #![allow(dead_code, clippy::all)]
    pub use alloc_crate::string::String;
    #[cfg(target_arch = "wasm32")]
    pub fn run_ctors_once() {
        wit_bindgen_rt::run_ctors_once();
    }
    pub fn as_i32<T: AsI32>(t: T) -> i32 {
        t.as_i32()
    }
    pub trait AsI32 {
        fn as_i32(self) -> i32;
    }
    impl<'a, T: Copy + AsI32> AsI32 for &'a T {
        fn as_i32(self) -> i32 {
            (*self).as_i32()
        }
    }
    impl AsI32 for i32 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for u32 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for i16 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for u16 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for i8 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for u8 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for char {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for usize {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    pub unsafe fn cabi_dealloc(ptr: *mut u8, size: usize, align: usize) {
        if size == 0 {
            return;
        }
        let layout = alloc::Layout::from_size_align_unchecked(size, align);
        alloc::dealloc(ptr, layout);
    }
    pub unsafe fn bool_lift(val: u8) -> bool {
        if cfg!(debug_assertions) {
            match val {
                0 => false,
                1 => true,
                _ => panic!("invalid bool discriminant"),
            }
        } else {
            val != 0
        }
    }
    extern crate alloc as alloc_crate;
    pub use alloc_crate::alloc;
}
/// Generates `#[unsafe(no_mangle)]` functions to export the specified type as
/// the root implementation of all generated traits.
///
/// For more information see the documentation of `wit_bindgen::generate!`.
///
/// ```rust
/// # macro_rules! export{ ($($t:tt)*) => (); }
/// # trait Guest {}
/// struct MyType;
///
/// impl Guest for MyType {
///     // ...
/// }
///
/// export!(MyType);
/// ```
#[allow(unused_macros)]
#[doc(hidden)]
macro_rules! __export_combat_impl {
    ($ty:ident) => {
        self::export!($ty with_types_in self);
    };
    ($ty:ident with_types_in $($path_to_types_root:tt)*) => {
        $($path_to_types_root)*::
        exports::docs::combat::types::__export_docs_combat_types_0_1_0_cabi!($ty
        with_types_in $($path_to_types_root)*:: exports::docs::combat::types);
        $($path_to_types_root)*::
        exports::docs::combat::damage::__export_docs_combat_damage_0_1_0_cabi!($ty
        with_types_in $($path_to_types_root)*:: exports::docs::combat::damage);
        $($path_to_types_root)*::
        exports::docs::combat::actions::__export_docs_combat_actions_0_1_0_cabi!($ty
        with_types_in $($path_to_types_root)*:: exports::docs::combat::actions);
        $($path_to_types_root)*::
        exports::docs::combat::battle::__export_docs_combat_battle_0_1_0_cabi!($ty
        with_types_in $($path_to_types_root)*:: exports::docs::combat::battle);
    };
}
#[doc(inline)]
pub(crate) use __export_combat_impl as export;
#[cfg(target_arch = "wasm32")]
#[unsafe(
    link_section = "component-type:wit-bindgen:0.41.0:docs:combat@0.1.0:combat:encoded world"
)]
#[doc(hidden)]
#[allow(clippy::octal_escapes)]
pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 1538] = *b"\
\0asm\x0d\0\x01\0\0\x19\x16wit-component-encoding\x04\0\x07\x85\x0b\x01A\x02\x01\
A\x0c\x01B\x08\x01m\x05\x0bsword-slash\x0bspin-attack\x08bow-shot\x0cmagic-attac\
k\x0bshield-bash\x04\0\x0battack-type\x03\0\0\x01r\x05\x0cdamage-dealty\x0bis-cr\
itical\x7f\x0ftarget-defeated\x7f\x0aexp-gainedy\x07messages\x04\0\x0dcombat-res\
ult\x03\0\x02\x01r\x05\x06attacky\x07defensey\x06healthy\x0amax-healthy\x0fequip\
ment-bonusy\x04\0\x0fcombatant-stats\x03\0\x04\x01r\x05\x09is-active\x7f\x0aturn\
-county\x0dplayer-healthy\x0cenemy-healthy\x0eis-player-turn\x7f\x04\0\x0cbattle\
-state\x03\0\x06\x04\0\x17docs:combat/types@0.1.0\x05\0\x02\x03\0\0\x0battack-ty\
pe\x02\x03\0\0\x0fcombatant-stats\x01B\x0e\x02\x03\x02\x01\x01\x04\0\x0battack-t\
ype\x03\0\0\x02\x03\x02\x01\x02\x04\0\x0fcombatant-stats\x03\0\x02\x01@\x02\x06a\
ttack\x01\x0eattacker-stats\x03\0y\x04\0\x15calculate-base-damage\x01\x04\x01@\x02\
\x0araw-damagey\x10defender-defensey\0y\x04\0\x0dapply-defense\x01\x05\x01@\x01\x0f\
attacker-attacky\0y\x04\0\x0droll-critical\x01\x06\x01@\x02\x06damagey\x0bis-cri\
ticaly\0y\x04\0\x0eapply-critical\x01\x07\x01@\x03\x06attack\x01\x08attacker\x03\
\x08defender\x03\0y\x04\0\x16calculate-final-damage\x01\x08\x04\0\x18docs:combat\
/damage@0.1.0\x05\x03\x02\x03\0\0\x0dcombat-result\x02\x03\0\0\x0cbattle-state\x01\
B\x10\x02\x03\x02\x01\x01\x04\0\x0battack-type\x03\0\0\x02\x03\x02\x01\x04\x04\0\
\x0dcombat-result\x03\0\x02\x02\x03\x02\x01\x02\x04\0\x0fcombatant-stats\x03\0\x04\
\x02\x03\x02\x01\x05\x04\0\x0cbattle-state\x03\0\x06\x01@\x04\x06attack\x01\x0cp\
layer-stats\x05\x0benemy-stats\x05\x09enemy-expy\0\x03\x04\0\x0dplayer-attack\x01\
\x08\x01@\x03\x0cenemy-attacky\x0benemy-stats\x05\x0cplayer-stats\x05\0\x03\x04\0\
\x0cenemy-attack\x01\x09\x01@\x02\x06attack\x01\x0cplayer-stats\x05\0\x7f\x04\0\x12\
can-special-attack\x01\x0a\x01@\x02\x0cplayer-speedy\x0benemy-speedy\0\x7f\x04\0\
\x0cattempt-flee\x01\x0b\x04\0\x19docs:combat/actions@0.1.0\x05\x06\x01B\x0c\x02\
\x03\x02\x01\x05\x04\0\x0cbattle-state\x03\0\0\x01@\x02\x0dplayer-healthy\x0cene\
my-healthy\0\x01\x04\0\x0cstart-battle\x01\x02\x01@\x01\x05state\x01\0\x01\x04\0\
\x0aend-battle\x01\x03\x04\0\x09next-turn\x01\x03\x01@\x03\x05state\x01\x0dplaye\
r-healthy\x0cenemy-healthy\0\x01\x04\0\x0dupdate-health\x01\x04\x01@\x01\x05stat\
e\x01\0\x7f\x04\0\x0eis-battle-over\x01\x05\x04\0\x0aplayer-won\x01\x05\x04\0\x18\
docs:combat/battle@0.1.0\x05\x07\x04\0\x18docs:combat/combat@0.1.0\x04\0\x0b\x0c\
\x01\0\x06combat\x03\0\0\0G\x09producers\x01\x0cprocessed-by\x02\x0dwit-componen\
t\x070.227.1\x10wit-bindgen-rust\x060.41.0";
#[inline(never)]
#[doc(hidden)]
pub fn __link_custom_section_describing_imports() {
    wit_bindgen_rt::maybe_link_cabi_realloc();
}
