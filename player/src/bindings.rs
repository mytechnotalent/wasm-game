// Generated by `wit-bindgen` 0.41.0. DO NOT EDIT!
// Options used:
//   * runtime_path: "wit_bindgen_rt"
#[rustfmt::skip]
#[allow(dead_code, clippy::all)]
pub mod exports {
    pub mod docs {
        pub mod player {
            /// Direction enum for player movement.
            ///
            /// Represents the four cardinal directions the player can move
            /// in a top-down 2D game world.
            #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
            pub mod types {
                #[used]
                #[doc(hidden)]
                static __FORCE_SECTION_REF: fn() = super::super::super::super::__link_custom_section_describing_imports;
                /// Cardinal direction for movement.
                #[repr(u8)]
                #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
                pub enum Direction {
                    /// Move upward (north).
                    North,
                    /// Move downward (south).
                    South,
                    /// Move leftward (west).
                    West,
                    /// Move rightward (east).
                    East,
                }
                impl ::core::fmt::Debug for Direction {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        match self {
                            Direction::North => {
                                f.debug_tuple("Direction::North").finish()
                            }
                            Direction::South => {
                                f.debug_tuple("Direction::South").finish()
                            }
                            Direction::West => f.debug_tuple("Direction::West").finish(),
                            Direction::East => f.debug_tuple("Direction::East").finish(),
                        }
                    }
                }
                impl Direction {
                    #[doc(hidden)]
                    pub unsafe fn _lift(val: u8) -> Direction {
                        if !cfg!(debug_assertions) {
                            return ::core::mem::transmute(val);
                        }
                        match val {
                            0 => Direction::North,
                            1 => Direction::South,
                            2 => Direction::West,
                            3 => Direction::East,
                            _ => panic!("invalid enum discriminant"),
                        }
                    }
                }
                /// Player position in 2D world coordinates.
                #[repr(C)]
                #[derive(Clone, Copy)]
                pub struct Position {
                    /// X coordinate (horizontal position).
                    pub x: i32,
                    /// Y coordinate (vertical position).
                    pub y: i32,
                }
                impl ::core::fmt::Debug for Position {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("Position")
                            .field("x", &self.x)
                            .field("y", &self.y)
                            .finish()
                    }
                }
                /// Player combat and health statistics.
                #[repr(C)]
                #[derive(Clone, Copy)]
                pub struct PlayerStats {
                    /// Current health points (0 = defeated).
                    pub health: u32,
                    /// Maximum health points.
                    pub max_health: u32,
                    /// Attack power for dealing damage.
                    pub attack: u32,
                    /// Defense rating for damage reduction.
                    pub defense: u32,
                    /// Current experience points.
                    pub experience: u32,
                    /// Current player level.
                    pub level: u32,
                }
                impl ::core::fmt::Debug for PlayerStats {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("PlayerStats")
                            .field("health", &self.health)
                            .field("max-health", &self.max_health)
                            .field("attack", &self.attack)
                            .field("defense", &self.defense)
                            .field("experience", &self.experience)
                            .field("level", &self.level)
                            .finish()
                    }
                }
                #[doc(hidden)]
                macro_rules! __export_docs_player_types_0_1_0_cabi {
                    ($ty:ident with_types_in $($path_to_types:tt)*) => {
                        const _ : () = {};
                    };
                }
                #[doc(hidden)]
                pub(crate) use __export_docs_player_types_0_1_0_cabi;
            }
            /// Player movement interface.
            ///
            /// Provides functions for moving the player character
            /// within the game world grid.
            #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
            pub mod movement {
                #[used]
                #[doc(hidden)]
                static __FORCE_SECTION_REF: fn() = super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type Direction = super::super::super::super::exports::docs::player::types::Direction;
                pub type Position = super::super::super::super::exports::docs::player::types::Position;
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_move_player_cabi<T: Guest>(
                    arg0: i32,
                    arg1: i32,
                    arg2: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::move_player(
                        super::super::super::super::exports::docs::player::types::Position {
                            x: arg0,
                            y: arg1,
                        },
                        super::super::super::super::exports::docs::player::types::Direction::_lift(
                            arg2 as u8,
                        ),
                    );
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let super::super::super::super::exports::docs::player::types::Position {
                        x: x2,
                        y: y2,
                    } = result0;
                    *ptr1.add(0).cast::<i32>() = _rt::as_i32(x2);
                    *ptr1.add(4).cast::<i32>() = _rt::as_i32(y2);
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_calculate_distance_cabi<T: Guest>(
                    arg0: i32,
                    arg1: i32,
                    arg2: i32,
                    arg3: i32,
                ) -> i32 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::calculate_distance(
                        super::super::super::super::exports::docs::player::types::Position {
                            x: arg0,
                            y: arg1,
                        },
                        super::super::super::super::exports::docs::player::types::Position {
                            x: arg2,
                            y: arg3,
                        },
                    );
                    _rt::as_i32(result0)
                }
                pub trait Guest {
                    /// Move the player one tile in the specified direction.
                    ///
                    /// Returns the new position after movement.
                    fn move_player(current_pos: Position, dir: Direction) -> Position;
                    /// Calculate distance between two positions (Manhattan distance).
                    fn calculate_distance(start: Position, end: Position) -> u32;
                }
                #[doc(hidden)]
                macro_rules! __export_docs_player_movement_0_1_0_cabi {
                    ($ty:ident with_types_in $($path_to_types:tt)*) => {
                        const _ : () = { #[unsafe (export_name =
                        "docs:player/movement@0.1.0#move-player")] unsafe extern "C" fn
                        export_move_player(arg0 : i32, arg1 : i32, arg2 : i32,) -> * mut
                        u8 { unsafe { $($path_to_types)*:: _export_move_player_cabi::<$ty
                        > (arg0, arg1, arg2) } } #[unsafe (export_name =
                        "docs:player/movement@0.1.0#calculate-distance")] unsafe extern
                        "C" fn export_calculate_distance(arg0 : i32, arg1 : i32, arg2 :
                        i32, arg3 : i32,) -> i32 { unsafe { $($path_to_types)*::
                        _export_calculate_distance_cabi::<$ty > (arg0, arg1, arg2, arg3)
                        } } };
                    };
                }
                #[doc(hidden)]
                pub(crate) use __export_docs_player_movement_0_1_0_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 8]);
                static mut _RET_AREA: _RetArea = _RetArea(
                    [::core::mem::MaybeUninit::uninit(); 8],
                );
            }
            /// Player health and stats interface.
            ///
            /// Manages the player's health pool and combat statistics.
            #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
            pub mod stats {
                #[used]
                #[doc(hidden)]
                static __FORCE_SECTION_REF: fn() = super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type PlayerStats = super::super::super::super::exports::docs::player::types::PlayerStats;
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_create_player_cabi<T: Guest>() -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::create_player();
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let super::super::super::super::exports::docs::player::types::PlayerStats {
                        health: health2,
                        max_health: max_health2,
                        attack: attack2,
                        defense: defense2,
                        experience: experience2,
                        level: level2,
                    } = result0;
                    *ptr1.add(0).cast::<i32>() = _rt::as_i32(health2);
                    *ptr1.add(4).cast::<i32>() = _rt::as_i32(max_health2);
                    *ptr1.add(8).cast::<i32>() = _rt::as_i32(attack2);
                    *ptr1.add(12).cast::<i32>() = _rt::as_i32(defense2);
                    *ptr1.add(16).cast::<i32>() = _rt::as_i32(experience2);
                    *ptr1.add(20).cast::<i32>() = _rt::as_i32(level2);
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_take_damage_cabi<T: Guest>(
                    arg0: i32,
                    arg1: i32,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                    arg5: i32,
                    arg6: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::take_damage(
                        super::super::super::super::exports::docs::player::types::PlayerStats {
                            health: arg0 as u32,
                            max_health: arg1 as u32,
                            attack: arg2 as u32,
                            defense: arg3 as u32,
                            experience: arg4 as u32,
                            level: arg5 as u32,
                        },
                        arg6 as u32,
                    );
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let super::super::super::super::exports::docs::player::types::PlayerStats {
                        health: health2,
                        max_health: max_health2,
                        attack: attack2,
                        defense: defense2,
                        experience: experience2,
                        level: level2,
                    } = result0;
                    *ptr1.add(0).cast::<i32>() = _rt::as_i32(health2);
                    *ptr1.add(4).cast::<i32>() = _rt::as_i32(max_health2);
                    *ptr1.add(8).cast::<i32>() = _rt::as_i32(attack2);
                    *ptr1.add(12).cast::<i32>() = _rt::as_i32(defense2);
                    *ptr1.add(16).cast::<i32>() = _rt::as_i32(experience2);
                    *ptr1.add(20).cast::<i32>() = _rt::as_i32(level2);
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_heal_cabi<T: Guest>(
                    arg0: i32,
                    arg1: i32,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                    arg5: i32,
                    arg6: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::heal(
                        super::super::super::super::exports::docs::player::types::PlayerStats {
                            health: arg0 as u32,
                            max_health: arg1 as u32,
                            attack: arg2 as u32,
                            defense: arg3 as u32,
                            experience: arg4 as u32,
                            level: arg5 as u32,
                        },
                        arg6 as u32,
                    );
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let super::super::super::super::exports::docs::player::types::PlayerStats {
                        health: health2,
                        max_health: max_health2,
                        attack: attack2,
                        defense: defense2,
                        experience: experience2,
                        level: level2,
                    } = result0;
                    *ptr1.add(0).cast::<i32>() = _rt::as_i32(health2);
                    *ptr1.add(4).cast::<i32>() = _rt::as_i32(max_health2);
                    *ptr1.add(8).cast::<i32>() = _rt::as_i32(attack2);
                    *ptr1.add(12).cast::<i32>() = _rt::as_i32(defense2);
                    *ptr1.add(16).cast::<i32>() = _rt::as_i32(experience2);
                    *ptr1.add(20).cast::<i32>() = _rt::as_i32(level2);
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_gain_experience_cabi<T: Guest>(
                    arg0: i32,
                    arg1: i32,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                    arg5: i32,
                    arg6: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::gain_experience(
                        super::super::super::super::exports::docs::player::types::PlayerStats {
                            health: arg0 as u32,
                            max_health: arg1 as u32,
                            attack: arg2 as u32,
                            defense: arg3 as u32,
                            experience: arg4 as u32,
                            level: arg5 as u32,
                        },
                        arg6 as u32,
                    );
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let super::super::super::super::exports::docs::player::types::PlayerStats {
                        health: health2,
                        max_health: max_health2,
                        attack: attack2,
                        defense: defense2,
                        experience: experience2,
                        level: level2,
                    } = result0;
                    *ptr1.add(0).cast::<i32>() = _rt::as_i32(health2);
                    *ptr1.add(4).cast::<i32>() = _rt::as_i32(max_health2);
                    *ptr1.add(8).cast::<i32>() = _rt::as_i32(attack2);
                    *ptr1.add(12).cast::<i32>() = _rt::as_i32(defense2);
                    *ptr1.add(16).cast::<i32>() = _rt::as_i32(experience2);
                    *ptr1.add(20).cast::<i32>() = _rt::as_i32(level2);
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_is_defeated_cabi<T: Guest>(
                    arg0: i32,
                    arg1: i32,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                    arg5: i32,
                ) -> i32 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::is_defeated(super::super::super::super::exports::docs::player::types::PlayerStats {
                        health: arg0 as u32,
                        max_health: arg1 as u32,
                        attack: arg2 as u32,
                        defense: arg3 as u32,
                        experience: arg4 as u32,
                        level: arg5 as u32,
                    });
                    match result0 {
                        true => 1,
                        false => 0,
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_exp_to_next_level_cabi<T: Guest>(
                    arg0: i32,
                ) -> i32 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::exp_to_next_level(arg0 as u32);
                    _rt::as_i32(result0)
                }
                pub trait Guest {
                    /// Create a new player with default starting stats.
                    fn create_player() -> PlayerStats;
                    /// Apply damage to the player, considering defense.
                    ///
                    /// Returns updated stats after damage calculation.
                    fn take_damage(stats: PlayerStats, raw_damage: u32) -> PlayerStats;
                    /// Heal the player by the specified amount.
                    ///
                    /// Cannot exceed max-health.
                    fn heal(stats: PlayerStats, amount: u32) -> PlayerStats;
                    /// Add experience points and handle level-up.
                    ///
                    /// Returns updated stats with new experience and potentially new level.
                    fn gain_experience(stats: PlayerStats, exp: u32) -> PlayerStats;
                    /// Check if the player is defeated (health = 0).
                    fn is_defeated(stats: PlayerStats) -> bool;
                    /// Get the experience needed for the next level.
                    fn exp_to_next_level(current_level: u32) -> u32;
                }
                #[doc(hidden)]
                macro_rules! __export_docs_player_stats_0_1_0_cabi {
                    ($ty:ident with_types_in $($path_to_types:tt)*) => {
                        const _ : () = { #[unsafe (export_name =
                        "docs:player/stats@0.1.0#create-player")] unsafe extern "C" fn
                        export_create_player() -> * mut u8 { unsafe {
                        $($path_to_types)*:: _export_create_player_cabi::<$ty > () } }
                        #[unsafe (export_name = "docs:player/stats@0.1.0#take-damage")]
                        unsafe extern "C" fn export_take_damage(arg0 : i32, arg1 : i32,
                        arg2 : i32, arg3 : i32, arg4 : i32, arg5 : i32, arg6 : i32,) -> *
                        mut u8 { unsafe { $($path_to_types)*::
                        _export_take_damage_cabi::<$ty > (arg0, arg1, arg2, arg3, arg4,
                        arg5, arg6) } } #[unsafe (export_name =
                        "docs:player/stats@0.1.0#heal")] unsafe extern "C" fn
                        export_heal(arg0 : i32, arg1 : i32, arg2 : i32, arg3 : i32, arg4
                        : i32, arg5 : i32, arg6 : i32,) -> * mut u8 { unsafe {
                        $($path_to_types)*:: _export_heal_cabi::<$ty > (arg0, arg1, arg2,
                        arg3, arg4, arg5, arg6) } } #[unsafe (export_name =
                        "docs:player/stats@0.1.0#gain-experience")] unsafe extern "C" fn
                        export_gain_experience(arg0 : i32, arg1 : i32, arg2 : i32, arg3 :
                        i32, arg4 : i32, arg5 : i32, arg6 : i32,) -> * mut u8 { unsafe {
                        $($path_to_types)*:: _export_gain_experience_cabi::<$ty > (arg0,
                        arg1, arg2, arg3, arg4, arg5, arg6) } } #[unsafe (export_name =
                        "docs:player/stats@0.1.0#is-defeated")] unsafe extern "C" fn
                        export_is_defeated(arg0 : i32, arg1 : i32, arg2 : i32, arg3 :
                        i32, arg4 : i32, arg5 : i32,) -> i32 { unsafe {
                        $($path_to_types)*:: _export_is_defeated_cabi::<$ty > (arg0,
                        arg1, arg2, arg3, arg4, arg5) } } #[unsafe (export_name =
                        "docs:player/stats@0.1.0#exp-to-next-level")] unsafe extern "C"
                        fn export_exp_to_next_level(arg0 : i32,) -> i32 { unsafe {
                        $($path_to_types)*:: _export_exp_to_next_level_cabi::<$ty >
                        (arg0) } } };
                    };
                }
                #[doc(hidden)]
                pub(crate) use __export_docs_player_stats_0_1_0_cabi;
                #[repr(align(4))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 24]);
                static mut _RET_AREA: _RetArea = _RetArea(
                    [::core::mem::MaybeUninit::uninit(); 24],
                );
            }
        }
    }
}
#[rustfmt::skip]
mod _rt {
    #![allow(dead_code, clippy::all)]
    #[cfg(target_arch = "wasm32")]
    pub fn run_ctors_once() {
        wit_bindgen_rt::run_ctors_once();
    }
    pub fn as_i32<T: AsI32>(t: T) -> i32 {
        t.as_i32()
    }
    pub trait AsI32 {
        fn as_i32(self) -> i32;
    }
    impl<'a, T: Copy + AsI32> AsI32 for &'a T {
        fn as_i32(self) -> i32 {
            (*self).as_i32()
        }
    }
    impl AsI32 for i32 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for u32 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for i16 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for u16 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for i8 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for u8 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for char {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for usize {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
}
/// Generates `#[unsafe(no_mangle)]` functions to export the specified type as
/// the root implementation of all generated traits.
///
/// For more information see the documentation of `wit_bindgen::generate!`.
///
/// ```rust
/// # macro_rules! export{ ($($t:tt)*) => (); }
/// # trait Guest {}
/// struct MyType;
///
/// impl Guest for MyType {
///     // ...
/// }
///
/// export!(MyType);
/// ```
#[allow(unused_macros)]
#[doc(hidden)]
macro_rules! __export_player_impl {
    ($ty:ident) => {
        self::export!($ty with_types_in self);
    };
    ($ty:ident with_types_in $($path_to_types_root:tt)*) => {
        $($path_to_types_root)*::
        exports::docs::player::types::__export_docs_player_types_0_1_0_cabi!($ty
        with_types_in $($path_to_types_root)*:: exports::docs::player::types);
        $($path_to_types_root)*::
        exports::docs::player::movement::__export_docs_player_movement_0_1_0_cabi!($ty
        with_types_in $($path_to_types_root)*:: exports::docs::player::movement);
        $($path_to_types_root)*::
        exports::docs::player::stats::__export_docs_player_stats_0_1_0_cabi!($ty
        with_types_in $($path_to_types_root)*:: exports::docs::player::stats);
    };
}
#[doc(inline)]
pub(crate) use __export_player_impl as export;
#[cfg(target_arch = "wasm32")]
#[unsafe(
    link_section = "component-type:wit-bindgen:0.41.0:docs:player@0.1.0:player:encoded world"
)]
#[doc(hidden)]
#[allow(clippy::octal_escapes)]
pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 780] = *b"\
\0asm\x0d\0\x01\0\0\x19\x16wit-component-encoding\x04\0\x07\x8f\x05\x01A\x02\x01\
A\x09\x01B\x06\x01m\x04\x05north\x05south\x04west\x04east\x04\0\x09direction\x03\
\0\0\x01r\x02\x01xz\x01yz\x04\0\x08position\x03\0\x02\x01r\x06\x06healthy\x0amax\
-healthy\x06attacky\x07defensey\x0aexperiencey\x05levely\x04\0\x0cplayer-stats\x03\
\0\x04\x04\0\x17docs:player/types@0.1.0\x05\0\x02\x03\0\0\x09direction\x02\x03\0\
\0\x08position\x01B\x08\x02\x03\x02\x01\x01\x04\0\x09direction\x03\0\0\x02\x03\x02\
\x01\x02\x04\0\x08position\x03\0\x02\x01@\x02\x0bcurrent-pos\x03\x03dir\x01\0\x03\
\x04\0\x0bmove-player\x01\x04\x01@\x02\x05start\x03\x03end\x03\0y\x04\0\x12calcu\
late-distance\x01\x05\x04\0\x1adocs:player/movement@0.1.0\x05\x03\x02\x03\0\0\x0c\
player-stats\x01B\x0e\x02\x03\x02\x01\x04\x04\0\x0cplayer-stats\x03\0\0\x01@\0\0\
\x01\x04\0\x0dcreate-player\x01\x02\x01@\x02\x05stats\x01\x0araw-damagey\0\x01\x04\
\0\x0btake-damage\x01\x03\x01@\x02\x05stats\x01\x06amounty\0\x01\x04\0\x04heal\x01\
\x04\x01@\x02\x05stats\x01\x03expy\0\x01\x04\0\x0fgain-experience\x01\x05\x01@\x01\
\x05stats\x01\0\x7f\x04\0\x0bis-defeated\x01\x06\x01@\x01\x0dcurrent-levely\0y\x04\
\0\x11exp-to-next-level\x01\x07\x04\0\x17docs:player/stats@0.1.0\x05\x05\x04\0\x18\
docs:player/player@0.1.0\x04\0\x0b\x0c\x01\0\x06player\x03\0\0\0G\x09producers\x01\
\x0cprocessed-by\x02\x0dwit-component\x070.227.1\x10wit-bindgen-rust\x060.41.0";
#[inline(never)]
#[doc(hidden)]
pub fn __link_custom_section_describing_imports() {
    wit_bindgen_rt::maybe_link_cabi_realloc();
}
